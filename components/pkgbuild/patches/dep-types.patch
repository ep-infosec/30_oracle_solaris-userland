# Patch Origin: in house
# Patch Status: The patch has to be upstreamed
# Patch Description: The patch handles conditional and require-any dependencies that gets generated by pkgbuild resolve command.

--- pkgbuild-1.3.105/pkgbuild.pl.in.orig	2020-01-06 22:52:43.295694350 +0000
+++ pkgbuild-1.3.105/pkgbuild.pl.in	2020-01-06 22:55:50.237958295 +0000
@@ -1578,11 +1578,11 @@
 	    #   %@ or %{@} expands to the name of the file
 	    #   %{basename:foo} expands to the basename of the foo
 	    my $tag = "$tagref";
-	    $tag =~ s/%{@}/$ipsfname/g;
+	    $tag =~ s/%\{@}/$ipsfname/g;
 	    $tag =~ s/%@/$ipsfname/g;
-	    while ($tag =~ /%{basename:([^}]*)}/) {
+	    while ($tag =~ /%\{basename:([^}]*)}/) {
 		my $bname = basename($1);
-		$tag =~ s/%{basename:([^}]*)}/$bname/;
+		$tag =~ s/%\{basename:([^}]*)}/$bname/;
 	    }
 	    # filter out duplicate tags
 	    if (index(" $line "," $tag ") == -1) {
@@ -2052,7 +2052,9 @@
     my @packages = $spec->get_packages();
     my @deps;
     my @autodeps = ();
-    my %autodep_hash;
+    my %autodep_hash_req;
+    my %autodep_hash_reqany;
+    my %autodep_hash_cond;
 
     if ($package->eval ('%_use_internal_dependency_generator') eq "1") {
 	print "Looking for dependencies using the internal dependency generator\n";
@@ -2080,13 +2082,29 @@
 	    }
 	    `rm -f $tmpfile`;
 	    my $ips_name = $package->get_ips_name ();
-	    foreach my $pkgname (@autodeps) {
+	    # Store values for conditional, require and require-any dependencies in separate variables
+	    foreach my $dependency (@autodeps) {
+		my @dep_list = split / /, $dependency;
+		my $pkgname = $dep_list[1];
 		chomp ($pkgname);
+		chomp($dep_list[-1]);
 		my $versionless = $pkgname;
 		$versionless =~ s/@.*//;
 		next if $versionless eq $ips_name;
-		print "  dependency discovered: $pkgname\n";
-		$autodep_hash{$versionless} = $pkgname;
+		if ($dep_list[0] eq "conditional") {
+		    print "  conditional dependency discovered: $pkgname\n";
+		    $autodep_hash_cond{$versionless} = \@dep_list;
+		}
+		if ($dep_list[0] eq "require-any") {
+		    my $pkgname_list = join ' ', @dep_list[1..$#dep_list];
+		    chomp($pkgname_list);
+		    print "  require-any dependency discovered: $pkgname_list\n";
+		    $autodep_hash_reqany{$versionless} = \@dep_list;
+		}
+		if ($dep_list[0] eq "require") {
+		    print "  require dependency discovered: $pkgname\n";
+		    $autodep_hash_req{$versionless} = \@dep_list;
+		}
 	    }
 	} else {
 	    print "No files to analyse\n";
@@ -2132,7 +2150,7 @@
 	    my $ips_dep = $pkg->get_ips_name();
 	    my $versionless = $ips_dep;
 	    $versionless =~ s/@.*//;
-	    delete ($autodep_hash{$versionless});
+	    delete ($autodep_hash_req{$versionless});
 	    my $minversion;
 	    if ($version_spec =~ />=\s*(\S+)/) {
 		# check if the version exists
@@ -2158,7 +2176,7 @@
 	if (defined ($ips_dep)) {
 	    my $versionless = $ips_dep;
 	    $versionless =~ s/@.*//;
-	    delete ($autodep_hash{$versionless});
+	    delete ($autodep_hash_req{$versionless});
 	    my $minversion;
 	    if ($version_spec =~ />=\s*(\S+)/) {
 		# check if the version exists
@@ -2217,9 +2235,17 @@
 	    }
 	}
     }
-    foreach my $ips_dep (keys %autodep_hash) {
-	push @dep_lines, "depend fmri=$autodep_hash{$ips_dep} type=require";
-    }
+    # Formulate depend line based on dependency type
+    foreach my $ips_dep (keys %autodep_hash_req) {
+	push @dep_lines, "depend fmri=$autodep_hash_req{$ips_dep}[1] type=require";
+    }
+    foreach my $ips_dep (keys %autodep_hash_cond) {
+	push @dep_lines, "depend fmri=$autodep_hash_cond{$ips_dep}[1] $autodep_hash_cond{$ips_dep}[2] type=conditional";
+    }
+    foreach my $ips_dep (keys %autodep_hash_reqany) {
+	my $pkgname_list1 = join ' fmri=', @{$autodep_hash_reqany{$ips_dep}}[1..$#{$autodep_hash_reqany{$ips_dep}}];
+	push @dep_lines, "depend fmri=$pkgname_list1 type=require-any";
+    }    
     push @$ref_lines, _uniq (@dep_lines);
     return 1;
 }
--- pkgbuild-1.3.105-orig/ips-dependency-generator	2012-11-25 18:34:21.000000000 -0800
+++ pkgbuild-1.3.105-changed/ips-dependency-generator	2017-08-29 23:57:09.816779726 -0700
@@ -24,10 +24,21 @@
 #
 
 #
-# This script prints IPS dependencies based on the filelist provided as
-# an argument.
+# This script prints dependency type and IPS dependencies based on the filelist
+# provided as an argument. The script handles only require, require-any and
+# conditional dependencies.
+#
+# The output format is:
+# <dependency-type> <IPS-package-fmri> <other-arguments>
+#
+# Typical output seen for require, require-any and conditional dependencies are
+# shown below:
+#
+# require <IPS-package-fmri>
+# require-any <IPS-package-fmri-1> <IPS-package-fmri-2> ... <IPS-package-fmri-N>
+# conditional <IPS-package-fmri> predicate=<predicate-fmri>
+#
 
-
 # NAME
 # 	print_help_and_exit
 #
@@ -123,18 +134,42 @@
 	    # no dependencies discovered in any of the files in the package
 	    true
 	else
-	    deps="$(cat "${generate_tmp}.res" | grep '^depend' | \
-	        sed -e 's/^depend fmri=\([^ ]*\) type=.*/\1/' | \
-                sed -e 's/^pkg:\///' | \
+	    deps_req="$(cat "${generate_tmp}.res" | grep '^depend' | \
+	        sed -e 's/^depend fmri=\([^ ]*\) type=require/require \1/' | \
+                sed -e 's/pkg:\///' | grep -v 'type=' | \
+                grep -v '^'$(basename ${generate_tmp})'$')"	  
+	    retval3=$?
+
+	    deps_reqany="$(cat "${generate_tmp}.res" | grep '^depend' | \
+                grep 'type=require-any' | sed -e 's/type=require-any//' | \
+                sed -e 's/depend /require-any/' | \
+	        sed -e 's/fmri=\([^ ]*\) / \1/g' | sed -e 's/pkg:\///g' | \
                 grep -v '^'$(basename ${generate_tmp})'$')"
-	    if [ $? != 0 ]; then
+	    retval3=$(($? & $retval3))
+
+	    deps_cond="$(cat "${generate_tmp}.res" | grep '^depend' | \
+                grep 'type=conditional' | sed -e 's/depend /conditional /' | \
+	        sed -e 's/fmri=\([^ ]*\)/\1/g' | sed -e 's/pkg:\///' | \
+                sed -e 's/type=conditional//' | sed -e 's/ $//' | \
+                grep -v '^'$(basename ${generate_tmp})'$')"
+	    retval3=$(($? & $retval3))
+
+	    if [ $retval3 != 0 ]; then
 	        return 1
 	    fi
 	fi
 
-	if [ "x$deps" != x ]; then
+	if [ "x$deps_req" != x -o "x$deps_reqany" != x -o "x$deps_cond" != x ]; then
 	    # some dependencies were found
-	    echo "$deps"
+	    if [ "x$deps_req" != x ]; then
+		echo "$deps_req"
+	    fi
+	    if [ "x$deps_reqany" != x ]; then
+		echo "$deps_reqany"
+	    fi
+	    if [ "x$deps_cond" != x ]; then
+		echo "$deps_cond"
+	    fi
 	    return $retval
 	else
 	    if [ $retval = 2 ]; then
