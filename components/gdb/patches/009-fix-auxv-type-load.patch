The core dumps produced by PIE binaries cannot be efficiently
debugged with GDB on SPARC because symbols were not loaded.

A simple test case:
$ echo 'int main(void) { return *(volatile int *)0=0; }' | \
  gcc -o segv -Og -g -fPIE -pie -x c -
$ ./segv
$ gdb -batch ./segv core -ex 'info sharedlibrary'
Segmentation Fault (core dumped)
[New LWP 1]
[New LWP 1]
Core was generated by `./segv.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffffffff7f400f04 in ?? ()
[Current thread is 2 (LWP 1)]
No shared libraries loaded at this time.

Besides that debug symbols were not loaded, it also failed
to load shared libraries. The backtrace is pretty unusable:
$ gdb -batch ./segv core -ex 'backtrace'
#0  0xffffffff7f400f04 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)

The analysis revealed that GDB failed to relocate binary's
sections and as a result, scan_dyntag function does not
find DT_DEBUG value in the target. Function svr4_exec_displacement
deals with the relocation of the binary, however, it failed
to find AT_ENTRY (entry address of the executable) in Solaris's
auxiliary vector, therefore, it returned the invalid zero offset
(it explains why it worked for non-PIE executables).

The reason why GDB failed to parse Solaris's auxiliary vector
is its different definition compared to Linux:

% File /usr/include/sys/auxv.h on Solaris:
 18 typedef struct
 19 {
 20   int a_type;
 21   union {
 22     long  a_val;
 23     void  *a_ptr;
 24     void  (*a_fcn)();
 25   } a_un;
 26 } auxv_t;

% File /usr/include/elf.h on Linux:
1147 typedef struct
1148 {
1149   uint64_t a_type;    /* Entry type */
1150   union
1151     {
1152       uint64_t a_val;   /* Integer value */
1153       /* We use to have pointer elements added here.  We cannot do that,
1154    though, since it does not work when using 32-bit definitions
1155    on 64-bit platforms and vice versa.  */
1156     } a_un;
1157 } Elf64_auxv_t;

GDB reads 8 bytes as an entry type, however, it only works on little-endian
architectures on the condition that padding is filled with zeros (fragile).
On SPARC it is reading invalid type values... The fix is to read only
sizeof(int) bytes on both architectures on Solaris.

The patch will be sent to upstream.

--- gdb-10.2/gdb/auxv.c	2021-05-24 08:07:34.933540320 +0000
+++ gdb-10.2/gdb/auxv.c	2021-05-24 07:53:51.103023650 +0000
@@ -267,7 +267,14 @@ generic_auxv_parse (struct gdbarch *gdba
   if (endptr - ptr < 2 * sizeof_auxv_val)
     return -1;
 
+  #if !defined(__sun) && !defined(__SVR4)
   *typep = extract_unsigned_integer (ptr, sizeof_auxv_type, byte_order);
+  #else
+  // On Solaris auxv_type is int, therefore, we have to load only first
+  // 4 bytes on SPARC to have valid type values (big-endian).
+  *typep = extract_unsigned_integer (ptr, sizeof(int), byte_order);
+  #endif
+
   /* Even if the auxv type takes less space than an auxv value, there is
      padding after the type such that the value is aligned on a multiple of
      its size (and this is why we advance by `sizeof_auxv_val` and not
@@ -540,6 +547,8 @@ default_print_auxv_entry (struct gdbarch
 	   AUXV_FORMAT_HEX);
       TAG (AT_SUN_CAP_HW2, _("Machine-dependent CPU capability hints 2"),
 	   AUXV_FORMAT_HEX);
+      TAG (AT_SUN_CAP_HW3, _("Machine-dependent CPU capability hints 3"),
+	   AUXV_FORMAT_HEX);
     }
 
   fprint_auxv_entry (file, name, description, format, type, val);
--- gdb-10.2/include/elf/common.h	2021-05-24 08:08:09.963763320 +0000
+++ gdb-10.2/include/elf/common.h	2021-05-24 07:54:11.273610650 +0000
@@ -1296,5 +1319,6 @@
 #define	AT_SUN_BRAND_AUX2 2021
 #define	AT_SUN_BRAND_AUX3 2022
 #define	AT_SUN_CAP_HW2	2023	/* Extension of AT_SUN_CAP_HW1.  */
+#define	AT_SUN_CAP_HW3	2024	/* Extension of AT_SUN_CAP_HW2.  */
 
 #endif /* _ELF_COMMON_H */
