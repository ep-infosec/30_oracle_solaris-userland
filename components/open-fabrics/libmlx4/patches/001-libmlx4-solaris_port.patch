#This patch was developed both in-house and from outside. We plan to submit it
#upstream, but do not yet have a target date for doing so
#
# HG changeset patch
# Parent  428f909809d31308ed8899463fa947e85a080c7c
libmlx4 solaris specific changes

diff -r 428f909809d3 Makefile.am
--- a/Makefile.am	Wed Oct 14 12:54:37 2015 -0700
+++ b/Makefile.am	Fri Nov 13 00:56:50 2015 -0800
@@ -13,7 +13,7 @@
 mlx4conf_DATA = mlx4.driver
 
 EXTRA_DIST = src/doorbell.h src/mlx4.h src/mlx4-abi.h src/wqe.h \
-    src/mlx4.map libmlx4.spec.in mlx4.driver
+    src/mlnx_umap.h src/mlx4.map libmlx4.spec.in mlx4.driver
 
 dist-hook: libmlx4.spec
 	cp libmlx4.spec $(distdir)
diff -r 428f909809d3 Makefile.in
--- a/Makefile.in	Wed Oct 14 12:54:37 2015 -0700
+++ b/Makefile.in	Fri Nov 13 00:56:50 2015 -0800
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# Makefile.in generated by automake 1.15 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+# Copyright (C) 1994-2014 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -16,7 +16,17 @@
 
 
 VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
 am__make_running_with_option = \
   case $${target_option-} in \
       ?) ;; \
@@ -80,21 +90,12 @@
 build_triplet = @build@
 host_triplet = @host@
 subdir = .
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/configure $(am__configure_deps) \
-	$(srcdir)/config.h.in $(srcdir)/libmlx4.spec.in \
-	$(top_srcdir)/config/depcomp AUTHORS COPYING README \
-	config/compile config/config.guess config/config.sub \
-	config/depcomp config/install-sh config/missing \
-	config/ltmain.sh $(top_srcdir)/config/compile \
-	$(top_srcdir)/config/config.guess \
-	$(top_srcdir)/config/config.sub \
-	$(top_srcdir)/config/install-sh $(top_srcdir)/config/ltmain.sh \
-	$(top_srcdir)/config/missing
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(am__DIST_COMMON)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
@@ -208,6 +209,15 @@
 CTAGS = ctags
 CSCOPE = cscope
 AM_RECURSIVE_TARGETS = cscope
+am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/config.h.in \
+	$(srcdir)/libmlx4.spec.in $(top_srcdir)/config/compile \
+	$(top_srcdir)/config/config.guess \
+	$(top_srcdir)/config/config.sub $(top_srcdir)/config/depcomp \
+	$(top_srcdir)/config/install-sh $(top_srcdir)/config/ltmain.sh \
+	$(top_srcdir)/config/missing AUTHORS COPYING README \
+	config/compile config/config.guess config/config.sub \
+	config/depcomp config/install-sh config/ltmain.sh \
+	config/missing
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -354,7 +364,7 @@
 mlx4confdir = $(sysconfdir)/libibverbs.d
 mlx4conf_DATA = mlx4.driver
 EXTRA_DIST = src/doorbell.h src/mlx4.h src/mlx4-abi.h src/wqe.h \
-    src/mlx4.map libmlx4.spec.in mlx4.driver
+    src/mlnx_umap.h src/mlx4.map libmlx4.spec.in mlx4.driver
 
 all: config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-am
@@ -376,7 +386,6 @@
 	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign Makefile
-.PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
@@ -653,15 +662,15 @@
 	$(am__post_remove_distdir)
 
 dist-tarZ: distdir
-	@echo WARNING: "Support for shar distribution archives is" \
-	               "deprecated." >&2
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
 	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
 	$(am__post_remove_distdir)
 
 dist-shar: distdir
-	@echo WARNING: "Support for distribution archives compressed with" \
-		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
 	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
 	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
 	$(am__post_remove_distdir)
@@ -697,17 +706,17 @@
 	esac
 	chmod -R a-w $(distdir)
 	chmod u+w $(distdir)
-	mkdir $(distdir)/_build $(distdir)/_inst
+	mkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst
 	chmod a-w $(distdir)
 	test -d $(distdir)/_build || exit 0; \
 	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
 	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
 	  && am__cwd=`pwd` \
-	  && $(am__cd) $(distdir)/_build \
-	  && ../configure \
+	  && $(am__cd) $(distdir)/_build/sub \
+	  && ../../configure \
 	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
 	    $(DISTCHECK_CONFIGURE_FLAGS) \
-	    --srcdir=.. --prefix="$$dc_install_base" \
+	    --srcdir=../.. --prefix="$$dc_install_base" \
 	  && $(MAKE) $(AM_MAKEFLAGS) \
 	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
 	  && $(MAKE) $(AM_MAKEFLAGS) check \
@@ -894,6 +903,8 @@
 	tags tags-am uninstall uninstall-am uninstall-libLTLIBRARIES \
 	uninstall-mlx4confDATA
 
+.PRECIOUS: Makefile
+
 
 dist-hook: libmlx4.spec
 	cp libmlx4.spec $(distdir)
diff -r 428f909809d3 aclocal.m4
--- a/aclocal.m4	Wed Oct 14 12:54:37 2015 -0700
+++ b/aclocal.m4	Fri Nov 13 00:56:50 2015 -0800
@@ -1,6 +1,6 @@
-# generated automatically by aclocal 1.14.1 -*- Autoconf -*-
-
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# generated automatically by aclocal 1.15 -*- Autoconf -*-
+
+# Copyright (C) 1996-2014 Free Software Foundation, Inc.
 
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -1326,7 +1326,7 @@
   rm -rf conftest*
   ;;
 
-x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
 s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
@@ -1338,19 +1338,9 @@
 	    LD="${LD-ld} -m elf_i386_fbsd"
 	    ;;
 	  x86_64-*linux*)
-	    case `/usr/bin/file conftest.o` in
-	      *x86-64*)
-		LD="${LD-ld} -m elf32_x86_64"
-		;;
-	      *)
-		LD="${LD-ld} -m elf_i386"
-		;;
-	    esac
+	    LD="${LD-ld} -m elf_i386"
 	    ;;
-	  powerpc64le-*)
-	    LD="${LD-ld} -m elf32lppclinux"
-	    ;;
-	  powerpc64-*)
+	  ppc64-*linux*|powerpc64-*linux*)
 	    LD="${LD-ld} -m elf32ppclinux"
 	    ;;
 	  s390x-*linux*)
@@ -1369,10 +1359,7 @@
 	  x86_64-*linux*)
 	    LD="${LD-ld} -m elf_x86_64"
 	    ;;
-	  powerpcle-*)
-	    LD="${LD-ld} -m elf64lppc"
-	    ;;
-	  powerpc-*)
+	  ppc*-*linux*|powerpc*-*linux*)
 	    LD="${LD-ld} -m elf64ppc"
 	    ;;
 	  s390*-*linux*|s390*-*tpf*)
@@ -1715,8 +1702,7 @@
     ;;
   *)
     lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
-    if test -n "$lt_cv_sys_max_cmd_len" && \
-	test undefined != "$lt_cv_sys_max_cmd_len"; then
+    if test -n "$lt_cv_sys_max_cmd_len"; then
       lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
       lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
     else
@@ -2540,6 +2526,17 @@
   esac
   ;;
 
+gnu*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
 haiku*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
@@ -2656,7 +2653,7 @@
   ;;
 
 # This must be glibc/ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
@@ -2701,18 +2698,6 @@
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -3272,6 +3257,10 @@
   fi
   ;;
 
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 haiku*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -3310,11 +3299,11 @@
   ;;
 
 # This must be glibc/ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-netbsd* | netbsdelf*-gnu)
+netbsd*)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
   else
@@ -4062,7 +4051,7 @@
 	    ;;
 	esac
 	;;
-      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
 	case $cc_basename in
 	  KCC*)
 	    # KAI C++ Compiler
@@ -4126,7 +4115,7 @@
 	    ;;
 	esac
 	;;
-      netbsd* | netbsdelf*-gnu)
+      netbsd*)
 	;;
       *qnx* | *nto*)
         # QNX uses GNU C++, but need to define -shared option too, otherwise
@@ -4361,7 +4350,7 @@
       _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
       ;;
 
-    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
       case $cc_basename in
       # old Intel for x86_64 which still supported -KPIC.
       ecc*)
@@ -4603,9 +4592,6 @@
       ;;
     esac
     ;;
-  linux* | k*bsd*-gnu | gnu*)
-    _LT_TAGVAR(link_all_deplibs, $1)=no
-    ;;
   *)
     _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
     ;;
@@ -4668,9 +4654,6 @@
   openbsd*)
     with_gnu_ld=no
     ;;
-  linux* | k*bsd*-gnu | gnu*)
-    _LT_TAGVAR(link_all_deplibs, $1)=no
-    ;;
   esac
 
   _LT_TAGVAR(ld_shlibs, $1)=yes
@@ -4892,7 +4875,7 @@
       fi
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
@@ -5069,7 +5052,6 @@
 	if test "$aix_use_runtimelinking" = yes; then
 	  shared_flag="$shared_flag "'${wl}-G'
 	fi
-	_LT_TAGVAR(link_all_deplibs, $1)=no
       else
 	# not using gcc
 	if test "$host_cpu" = ia64; then
@@ -5374,7 +5356,7 @@
       _LT_TAGVAR(link_all_deplibs, $1)=yes
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
       else
@@ -6250,6 +6232,9 @@
         _LT_TAGVAR(ld_shlibs, $1)=yes
         ;;
 
+      gnu*)
+        ;;
+
       haiku*)
         _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
         _LT_TAGVAR(link_all_deplibs, $1)=yes
@@ -6411,7 +6396,7 @@
         _LT_TAGVAR(inherit_rpath, $1)=yes
         ;;
 
-      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
         case $cc_basename in
           KCC*)
 	    # Kuck and Associates, Inc. (KAI) C++ Compiler
@@ -8622,7 +8607,7 @@
 m4_ifndef([_LT_PROG_FC],		[AC_DEFUN([_LT_PROG_FC])])
 m4_ifndef([_LT_PROG_CXX],		[AC_DEFUN([_LT_PROG_CXX])])
 
-# Copyright (C) 2002-2013 Free Software Foundation, Inc.
+# Copyright (C) 2002-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -8634,10 +8619,10 @@
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.14'
+[am__api_version='1.15'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.14.1], [],
+m4_if([$1], [1.15], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -8653,14 +8638,14 @@
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.14.1])dnl
+[AM_AUTOMAKE_VERSION([1.15])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -8705,15 +8690,14 @@
 # configured tree to be moved without reconfiguration.
 
 AC_DEFUN([AM_AUX_DIR_EXPAND],
-[dnl Rely on autoconf to set up CDPATH properly.
-AC_PREREQ([2.50])dnl
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
+[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
+# Expand $ac_aux_dir to an absolute path.
+am_aux_dir=`cd "$ac_aux_dir" && pwd`
 ])
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997-2013 Free Software Foundation, Inc.
+# Copyright (C) 1997-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -8744,7 +8728,7 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Copyright (C) 1999-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -8935,7 +8919,7 @@
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Copyright (C) 1999-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9011,7 +8995,7 @@
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9101,8 +9085,8 @@
 # <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
 # <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
 AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
+# We need awk for the "check" target (and possibly the TAP driver).  The
+# system "awk" is bad on some platforms.
 AC_REQUIRE([AC_PROG_AWK])dnl
 AC_REQUIRE([AC_PROG_MAKE_SET])dnl
 AC_REQUIRE([AM_SET_LEADING_DOT])dnl
@@ -9176,6 +9160,9 @@
     AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
   fi
 fi
+dnl The trailing newline in this macro's definition is deliberate, for
+dnl backward compatibility and to allow trailing 'dnl'-style comments
+dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.
 ])
 
 dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
@@ -9205,7 +9192,7 @@
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9216,7 +9203,7 @@
 # Define $install_sh.
 AC_DEFUN([AM_PROG_INSTALL_SH],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-if test x"${install_sh}" != xset; then
+if test x"${install_sh+set}" != xset; then
   case $am_aux_dir in
   *\ * | *\	*)
     install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
@@ -9226,7 +9213,7 @@
 fi
 AC_SUBST([install_sh])])
 
-# Copyright (C) 2003-2013 Free Software Foundation, Inc.
+# Copyright (C) 2003-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9247,7 +9234,7 @@
 
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9297,7 +9284,7 @@
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997-2013 Free Software Foundation, Inc.
+# Copyright (C) 1997-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9336,7 +9323,7 @@
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9365,7 +9352,7 @@
 AC_DEFUN([_AM_IF_OPTION],
 [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
 
-# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Copyright (C) 1999-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9412,7 +9399,7 @@
 # For backward compatibility.
 AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9431,7 +9418,7 @@
 
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Copyright (C) 1996-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9512,7 +9499,7 @@
 rm -f conftest.file
 ])
 
-# Copyright (C) 2009-2013 Free Software Foundation, Inc.
+# Copyright (C) 2009-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9572,7 +9559,7 @@
 _AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
 ])
 
-# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+# Copyright (C) 2001-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9600,7 +9587,7 @@
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006-2013 Free Software Foundation, Inc.
+# Copyright (C) 2006-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -9619,7 +9606,7 @@
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004-2013 Free Software Foundation, Inc.
+# Copyright (C) 2004-2014 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
diff -r 428f909809d3 configure
--- a/configure	Wed Oct 14 12:54:37 2015 -0700
+++ b/configure	Fri Nov 13 00:56:50 2015 -0800
@@ -2422,7 +2422,7 @@
 
 ac_config_headers="$ac_config_headers config.h"
 
-am__api_version='1.14'
+am__api_version='1.15'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
diff -r 428f909809d3 src/buf.c
--- a/src/buf.c	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/buf.c	Fri Nov 13 00:56:50 2015 -0800
@@ -60,7 +60,9 @@
 void mlx4_free_buf(struct mlx4_buf *buf)
 {
 	if (buf->length) {
+#if !(defined(__SVR4) && defined(__sun))
 		ibv_dofork_range(buf->buf, buf->length);
+#endif
 		munmap(buf->buf, buf->length);
 	}
 }
diff -r 428f909809d3 src/dbrec.c
--- a/src/dbrec.c	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/dbrec.c	Fri Nov 13 00:56:50 2015 -0800
@@ -41,6 +41,156 @@
 
 #include "mlx4.h"
 
+#if defined(__SVR4) && defined(__sun)
+/*
+ * In Solaris the doorbell UAR is setup by the kernel, we only
+ * mmap the offset specified for the doorbell into the user
+ * address space.  A reference counted page list is maintained
+ * per user context of doorbell pages that have been mapped.
+ */
+struct mlx4_db_page {
+	struct mlx4_db_page	   *prev, *next;
+	uint32_t                   *dbp_page_addr;
+	uint32_t                   *dbp_page_addr_end;
+	uint64_t                   dbp_map_offset;
+	uint64_t                   dbp_map_len;
+	int                        fd;
+	int                        dbp_use_cnt;
+};
+
+/*
+ * These are not required in Solaris, but we keep them to pass
+ * as dummy arguments so that the the doorbell function calls can
+ * keep the same API.
+ */
+static const int db_size[] = {
+	[MLX4_DB_TYPE_CQ] = 8,
+	[MLX4_DB_TYPE_RQ] = 4,
+};
+
+/*
+ * Return a doorbell pointer for the specified map offset.  If this
+ * offset has not been previously mapped it will be mmap'd and the
+ * appropriate doorbell returned; otherwise, the reference count
+ * will be updated and the appropriate doorbell will be returned.
+ * Each successful call to mlx4_alloc_db() must call mlx4_free_db()
+ * to release the reference to the doorbell page  when the doorbell
+ * is no longer required.
+ */
+uint32_t *mlx4_alloc_db(struct mlx4_context *context,
+                        uint64_t mapoffset,
+                        uint64_t maplen,
+                        uint32_t offset)
+{
+	struct mlx4_db_page *page;
+	uint32_t *db = NULL;
+
+	pthread_mutex_lock(&context->db_list_mutex);
+
+	for (page = context->db_page_list; page; page = page->next) {
+		if (page->dbp_map_offset == mapoffset &&
+		    page->fd == context->ibv_ctx.mmap_fd) {
+			if (page->dbp_map_len == maplen) {
+				goto found;
+			}
+			fprintf(stderr,
+			        PFX "mlx4_alloc_db: Bad maplen (%" PRId64 ")\n",
+			        maplen);
+			goto out;
+		}
+	}
+
+	page = malloc(sizeof(struct mlx4_db_page));
+	if (!page) {
+		fprintf(stderr, PFX "DB alloc memory allocate failure\n");
+		goto out;
+	}
+
+	page->dbp_page_addr = (uint32_t *) mmap64((void *)0, maplen,
+	                                          (PROT_READ | PROT_WRITE),
+	                                          MAP_SHARED,
+	                                          context->ibv_ctx.mmap_fd,
+	                                          mapoffset);
+	if (page->dbp_page_addr == MAP_FAILED) {
+		fprintf(stderr, PFX
+		        "Unable to map doorbell entry: maplen:%" PRId64 ", offset:%" PRId64
+		        "\n", maplen, mapoffset);
+		free(page);
+		goto out;
+	}
+
+	page->dbp_page_addr_end = (uint32_t *)((uint8_t *) page->dbp_page_addr + maplen);
+
+	page->dbp_map_offset  = mapoffset;
+	page->dbp_map_len     = maplen;
+	page->dbp_use_cnt     = 0;
+	page->fd	      = context->ibv_ctx.mmap_fd;
+	page->next            = context->db_page_list;
+
+	if (context->db_page_list)
+		context->db_page_list->prev = page;
+
+	page->prev            = NULL;
+	context->db_page_list = page;
+
+found:
+	page->dbp_use_cnt++;
+
+
+	db = (uint32_t *) ((uint8_t *)page->dbp_page_addr + offset);
+out:
+	pthread_mutex_unlock(&context->db_list_mutex);
+
+	return db;
+}
+
+/*
+ * Dereference doorbell page mappinge associated with the specified doorbell.
+ * If this is the last doorbell that references a mapped region, then that
+ * region will be unmapped.
+ */
+void mlx4_free_db(struct mlx4_context *context,
+                  enum mlx4_db_type dummy,
+                  uint32_t *db)
+{
+	struct mlx4_db_page *page;
+
+	pthread_mutex_lock(&context->db_list_mutex);
+
+	for (page = context->db_page_list; page; page = page->next) {
+		if (db >= page->dbp_page_addr && db < page->dbp_page_addr_end) {
+			break;
+		}
+	}
+
+	if (page == NULL) {
+		fprintf(stderr, PFX "mlx4_free_db: Doorbell not mapped\n");
+		goto out;
+	}
+
+	page->dbp_use_cnt--;
+	if (page->dbp_use_cnt > 0) {
+		goto out;
+	}
+
+	munmap((void *)page->dbp_page_addr, page->dbp_map_len);
+	if (page->next) {
+		page->next->prev = page->prev;
+	}
+	if (page->prev) {
+		page->prev->next = page->next;
+	} else {
+		context->db_page_list = page->next;
+	}
+
+	free(page);
+
+out:
+	pthread_mutex_unlock(&context->db_list_mutex);
+}
+
+#else
+
 struct mlx4_db_page {
 	struct mlx4_db_page	       *prev, *next;
 	struct mlx4_buf			buf;
@@ -152,3 +302,4 @@
 out:
 	pthread_mutex_unlock(&context->db_list_mutex);
 }
+#endif
diff -r 428f909809d3 src/mlx4-abi.h
--- a/src/mlx4-abi.h	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/mlx4-abi.h	Fri Nov 13 00:56:50 2015 -0800
@@ -35,6 +35,10 @@
 
 #include <infiniband/kern-abi.h>
 
+#if defined(__SVR4) && defined(__sun)
+#include <sys/ib/adapters/mlnx_umap.h>   /* Opaque CI data out definitions */
+#endif
+
 #define MLX4_UVERBS_MIN_ABI_VERSION	2
 #define MLX4_UVERBS_MAX_ABI_VERSION	4
 
@@ -49,6 +53,10 @@
 	__u32				qp_tab_size;
 	__u16				bf_reg_size;
 	__u16				bf_regs_per_page;
+#if defined(__SVR4) && defined(__sun)
+	uint32_t			muc_rev;
+	uint32_t			muc_reserved;
+#endif
 };
 
 struct mlx4_alloc_ucontext_resp {
@@ -58,6 +66,10 @@
 	__u16				bf_reg_size;
 	__u16				bf_regs_per_page;
 	__u32				cqe_size;
+#if defined(__SVR4) && defined(__sun)
+	uint32_t			muc_rev;
+	uint32_t			muc_reserved;
+#endif
 };
 
 struct mlx4_alloc_pd_resp {
@@ -68,25 +80,42 @@
 
 struct mlx4_create_cq {
 	struct ibv_create_cq		ibv_cmd;
+#if !(defined(__SVR4) && defined(__sun))
 	__u64				buf_addr;
 	__u64				db_addr;
+#endif
 };
 
 struct mlx4_create_cq_resp {
 	struct ibv_create_cq_resp	ibv_resp;
+#if !(defined(__SVR4) && defined(__sun))
 	__u32				cqn;
 	__u32				reserved;
+#else
+	mlnx_umap_cq_data_out_t		mdd;
+#endif
 };
 
 struct mlx4_resize_cq {
 	struct ibv_resize_cq		ibv_cmd;
+#if !(defined(__SVR4) && defined(__sun))
 	__u64				buf_addr;
+#endif
 };
 
+#if defined(__SVR4) && defined(__sun)
+struct mlx4_resize_cq_resp {
+	struct ibv_resize_cq_resp	ibv_resp;
+	mlnx_umap_cq_data_out_t		mdd;
+};
+#endif
+
 struct mlx4_create_srq {
 	struct ibv_create_srq		ibv_cmd;
+#if !(defined(__SVR4) && defined(__sun))
 	__u64				buf_addr;
 	__u64				db_addr;
+#endif
 };
 
 struct mlx4_create_xsrq {
@@ -97,18 +126,31 @@
 
 struct mlx4_create_srq_resp {
 	struct ibv_create_srq_resp	ibv_resp;
+#if !(defined(__SVR4) && defined(__sun))
 	__u32				srqn;
 	__u32				reserved;
+#else
+	mlnx_umap_srq_data_out_t	mdd;
+#endif
 };
 
 struct mlx4_create_qp {
 	struct ibv_create_qp		ibv_cmd;
+#if !(defined(__SVR4) && defined(__sun))
 	__u64				buf_addr;
 	__u64				db_addr;
 	__u8				log_sq_bb_count;
 	__u8				log_sq_stride;
 	__u8				sq_no_prefetch;	/* was reserved in ABI 2 */
 	__u8				reserved[5];
+#endif
 };
 
+#if defined(__SVR4) && defined(__sun)
+struct mlx4_create_qp_resp {
+	struct ibv_create_qp_resp	ibv_resp;
+	mlnx_umap_qp_data_out_t		mdd;
+};
+#endif
+
 #endif /* MLX4_ABI_H */
diff -r 428f909809d3 src/mlx4.c
--- a/src/mlx4.c	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/mlx4.c	Fri Nov 13 00:56:50 2015 -0800
@@ -127,6 +127,11 @@
 	__u16				bf_reg_size;
 	struct mlx4_device              *dev = to_mdev(&v_device->device);
 	struct verbs_context *verbs_ctx = verbs_get_ctx(ibv_ctx);
+#if defined(__SVR4) && defined(__sun)
+	pid_t                           cur_pid;
+	off64_t                         uarpg_offset;
+	uint32_t                        temp_qp_num;
+#endif
 
 	/* memory footprint of mlx4_context and verbs_context share
 	* struct ibv_context.
@@ -134,11 +139,29 @@
 	context = to_mctx(ibv_ctx);
 	ibv_ctx->cmd_fd = cmd_fd;
 
+#if defined(__SVR4) && defined(__sun)
+	ibv_ctx->device = &v_device->device;
+#endif
 	if (dev->abi_version <= MLX4_UVERBS_NO_DEV_CAPS_ABI_VERSION) {
 		if (ibv_cmd_get_context(ibv_ctx, &cmd, sizeof cmd,
 					&resp_v3.ibv_resp, sizeof resp_v3))
 			return errno;
+#if defined(__SVR4) && defined(__sun)
+		/* 
+		 * OFED expects power of two, round up here to make user table
+		 * large enough.
+		 */
+		for (temp_qp_num = 1; temp_qp_num < resp_v3.qp_tab_size; temp_qp_num <<= 1)
+			;
+		resp_v3.qp_tab_size = temp_qp_num;
 
+		/*
+		 * NOTE: In Solaris this value is not returned in the channel interface
+		 * opaque data and is assumed to be 2*256 by the dapl code.  We have
+		 * made the same assumption here.
+		 */
+		resp_v3.bf_reg_size = 512;
+#endif
 		context->num_qps  = resp_v3.qp_tab_size;
 		bf_reg_size	  = resp_v3.bf_reg_size;
 		context->cqe_size = sizeof (struct mlx4_cqe);
@@ -146,6 +169,22 @@
 		if (ibv_cmd_get_context(ibv_ctx, &cmd, sizeof cmd,
 					&resp.ibv_resp, sizeof resp))
 			return errno;
+#if defined(__SVR4) && defined(__sun)
+		/* 
+		 * OFED expects power of two, round up here to make user table
+		 * large enough.
+		 */
+		for (temp_qp_num = 1; temp_qp_num < resp.qp_tab_size; temp_qp_num <<= 1)
+			;
+		resp.qp_tab_size = temp_qp_num;
+
+		/*
+		 * NOTE: In Solaris this value is not returned in the channel interface
+		 * opaque data and is assumed to be 2*256 by the dapl code.  We have
+		 * made the same assumption here.
+		 */
+		resp.bf_reg_size = 512;
+#endif
 
 		context->num_qps  = resp.qp_tab_size;
 		bf_reg_size	  = resp.bf_reg_size;
@@ -162,21 +201,46 @@
 	for (i = 0; i < MLX4_QP_TABLE_SIZE; ++i)
 		context->qp_table[i].refcnt = 0;
 
+#if defined(__SVR4) && defined(__sun)
+	context->db_page_list = NULL;
+#else
 	for (i = 0; i < MLX4_NUM_DB_TYPE; ++i)
 		context->db_list[i] = NULL;
+#endif
 
 	mlx4_init_xsrq_table(&context->xsrq_table, context->num_qps);
 	pthread_mutex_init(&context->db_list_mutex, NULL);
 
+#if defined(__SVR4) && defined(__sun)
+	cur_pid = getpid();
+	uarpg_offset = (((off64_t) cur_pid << MLNX_UMAP_RSRC_TYPE_SHIFT) |
+	                MLNX_UMAP_UARPG_RSRC) * dev->page_size;
+	context->uar = mmap64((void *)0, dev->page_size, PROT_WRITE,
+			    MAP_SHARED, ibv_ctx->mmap_fd, uarpg_offset);
+#else
 	context->uar = mmap(NULL, dev->page_size, PROT_WRITE,
 			    MAP_SHARED, cmd_fd, 0);
+#endif
 	if (context->uar == MAP_FAILED)
 		return errno;
 
 	if (bf_reg_size) {
+#if defined(__SVR4) && defined(__sun)
+		/*
+		 * If kernel driver is supporting Blue Flame feature, map
+		 * the Blue Flame user access region as well.
+		 */
+		uarpg_offset = (((off64_t) cur_pid << MLNX_UMAP_RSRC_TYPE_SHIFT)
+		    | MLNX_UMAP_BLUEFLAMEPG_RSRC) * dev->page_size;
+
+		context->bf_page = mmap64((void *)0, dev->page_size,
+		    PROT_WRITE, MAP_SHARED, ibv_ctx->mmap_fd,
+		    uarpg_offset);
+#else
 		context->bf_page = mmap(NULL, dev->page_size,
 					PROT_WRITE, MAP_SHARED, cmd_fd,
 					dev->page_size);
+#endif
 		if (context->bf_page == MAP_FAILED) {
 			fprintf(stderr, PFX "Warning: BlueFlame available, "
 				"but failed to mmap() BlueFlame page.\n");
diff -r 428f909809d3 src/mlx4.h
--- a/src/mlx4.h	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/mlx4.h	Fri Nov 13 00:56:50 2015 -0800
@@ -185,7 +185,12 @@
 	int				qp_table_shift;
 	int				qp_table_mask;
 
+
+#if defined(__SVR4) && defined(__sun)
+	struct mlx4_db_page	       *db_page_list;
+#else
 	struct mlx4_db_page	       *db_list[MLX4_NUM_DB_TYPE];
+#endif
 	pthread_mutex_t			db_list_mutex;
 	int				cqe_size;
 	struct mlx4_xsrq_table		xsrq_table;
@@ -347,7 +352,12 @@
 int mlx4_alloc_buf(struct mlx4_buf *buf, size_t size, int page_size);
 void mlx4_free_buf(struct mlx4_buf *buf);
 
+#if defined(__SVR4) && defined(__sun)
+uint32_t *mlx4_alloc_db(struct mlx4_context *context, uint64_t mapoffset,
+                        uint64_t maplen, uint32_t offset);
+#else
 uint32_t *mlx4_alloc_db(struct mlx4_context *context, enum mlx4_db_type type);
+#endif
 void mlx4_free_db(struct mlx4_context *context, enum mlx4_db_type type, uint32_t *db);
 
 int mlx4_query_device(struct ibv_context *context,
@@ -393,8 +403,13 @@
 			   struct ibv_srq_attr *attr);
 int mlx4_destroy_srq(struct ibv_srq *srq);
 int mlx4_destroy_xrc_srq(struct ibv_srq *srq);
+#if defined(__SVR4) && defined(__sun)
+int mlx4_set_srq_buf(struct ibv_pd *pd, struct mlx4_srq *srq,
+			uint32_t srq_wqesz, uint32_t srq_numwqe);
+#else
 int mlx4_alloc_srq_buf(struct ibv_pd *pd, struct ibv_srq_attr *attr,
 			struct mlx4_srq *srq);
+#endif
 void mlx4_init_xsrq_table(struct mlx4_xsrq_table *xsrq_table, int size);
 struct mlx4_srq *mlx4_find_xsrq(struct mlx4_xsrq_table *xsrq_table, uint32_t srqn);
 int mlx4_store_xsrq(struct mlx4_xsrq_table *xsrq_table, uint32_t srqn,
@@ -423,8 +438,15 @@
 			  struct ibv_recv_wr **bad_wr);
 void mlx4_calc_sq_wqe_size(struct ibv_qp_cap *cap, enum ibv_qp_type type,
 			   struct mlx4_qp *qp);
+
+#if defined(__SVR4) && defined(__sun)
+int mlx4_set_qp_buf(struct ibv_pd *pd, struct mlx4_qp *qp,
+                    void *qpbuf, uint64_t buflen, uint32_t rq_wqesz,
+                     uint32_t rq_off, uint32_t sq_wqesz, uint32_t sq_off);
+#else
 int mlx4_alloc_qp_buf(struct ibv_context *context, struct ibv_qp_cap *cap,
 		       enum ibv_qp_type type, struct mlx4_qp *qp);
+#endif
 void mlx4_set_sq_sizes(struct mlx4_qp *qp, struct ibv_qp_cap *cap,
 		       enum ibv_qp_type type);
 struct mlx4_qp *mlx4_find_qp(struct mlx4_context *ctx, uint32_t qpn);
diff -r 428f909809d3 src/qp.c
--- a/src/qp.c	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/qp.c	Fri Nov 13 00:56:50 2015 -0800
@@ -587,6 +587,60 @@
 		; /* nothing */
 }
 
+#if defined(__SVR4) && defined(__sun)
+int mlx4_set_qp_buf(struct ibv_pd *pd, struct mlx4_qp *qp, void *qpbuf,
+    uint64_t buflen, uint32_t rq_wqesz, uint32_t rq_off,
+    uint32_t sq_wqesz, uint32_t sq_off)
+{
+	qp->buf.buf      = qpbuf;
+	qp->buf.length   = buflen;
+
+	qp->sq.wrid = malloc(qp->sq.wqe_cnt * sizeof (uint64_t));
+	if (!qp->sq.wrid)
+		return -1;
+
+	if (qp->rq.wqe_cnt) {
+		qp->rq.wrid = malloc(qp->rq.wqe_cnt * sizeof (uint64_t));
+		if (!qp->rq.wrid) {
+			free(qp->sq.wrid);
+			return -1;
+		}
+	}
+
+	for (qp->rq.wqe_shift = 4; 1 << qp->rq.wqe_shift < rq_wqesz;
+	     qp->rq.wqe_shift++) {
+		; /* nothing */
+	}
+
+	for (qp->sq.wqe_shift = 6; 1 << qp->sq.wqe_shift < sq_wqesz;
+	     qp->sq.wqe_shift++) {
+		; /* nothing */
+	}
+
+	qp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +
+		(qp->sq.wqe_cnt << qp->sq.wqe_shift);
+	if (qp->rq.wqe_shift > qp->sq.wqe_shift) {
+		qp->rq.offset = 0;
+		qp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;
+	} else {
+		qp->rq.offset = qp->sq.wqe_cnt << qp->sq.wqe_shift;
+		qp->sq.offset = 0;
+	}
+
+	if ((long int)qp->buf.length < (long int)qp->buf_size) {
+		fprintf(stderr, PFX "QP kernel buffer size %lu < user buf "
+		    "size %d\n", (unsigned long)qp->buf.length, qp->buf_size);
+	}
+	if ((!rq_off && qp->rq.offset) || (!sq_off && qp->sq.offset)) {
+		fprintf(stderr, PFX "QP kernel and user out of sync on "
+		    "buffer order\n");
+	}
+
+	memset(qp->buf.buf, 0, qp->buf_size);
+	return 0;
+}
+#endif
+
 int mlx4_alloc_qp_buf(struct ibv_context *context, struct ibv_qp_cap *cap,
 		       enum ibv_qp_type type, struct mlx4_qp *qp)
 {
diff -r 428f909809d3 src/srq.c
--- a/src/srq.c	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/srq.c	Fri Nov 13 00:56:50 2015 -0800
@@ -125,6 +125,54 @@
 	return err;
 }
 
+#if defined(__SVR4) && defined(__sun)
+/*
+ * The Solaris kernel allocates the SRQ WQE buffer, this routine
+ * initializes the control structures and buffer contents for the
+ * SRQ memory.  That memory is mapped into the caller's address
+ * space prior to this call.
+ */
+int mlx4_set_srq_buf(struct ibv_pd *pd, struct mlx4_srq *srq,
+				uint32_t srq_wqesz, uint32_t srq_numwqe)
+{
+	struct mlx4_wqe_srq_next_seg *next;
+	struct mlx4_wqe_data_seg *scatter;
+	int i;
+
+	srq->max         = srq_numwqe;
+
+	srq->wrid = malloc(srq->max * sizeof (uint64_t));
+	if (!srq->wrid) {
+		return -1;
+	}
+
+	for (srq->wqe_shift = 5; 1 << srq->wqe_shift < srq_wqesz; ++srq->wqe_shift) {
+		; /* nothing */
+	}
+
+	memset(srq->buf.buf, 0, srq->buf.length);
+
+	/*
+	 * Now initialize the SRQ buffer so that all of the WQEs are
+	 * linked into the list of free WQEs.
+	 */
+	for (i = 0; i < srq->max; ++i) {
+		next = get_wqe(srq, i);
+		next->next_wqe_index = htons((i + 1) & (srq->max - 1));
+
+		for (scatter = (void *) (next + 1);
+		    (void *) scatter < (void *) next + (1 << srq->wqe_shift);
+		    ++scatter)
+			scatter->lkey = htonl(MLX4_INVALID_LKEY);
+	}
+
+	srq->head = 0;
+	srq->tail = srq->max - 1;
+
+	return 0;
+}
+#endif
+
 int mlx4_alloc_srq_buf(struct ibv_pd *pd, struct ibv_srq_attr *attr,
 		       struct mlx4_srq *srq)
 {
@@ -254,6 +302,7 @@
 	if (pthread_spin_init(&srq->lock, PTHREAD_PROCESS_PRIVATE))
 		goto err;
 
+#if !(defined(__SVR4) && defined(__sun))
 	srq->max     = align_queue_size(attr_ex->attr.max_wr + 1);
 	srq->max_gs  = attr_ex->attr.max_sge;
 	srq->counter = 0;
@@ -267,6 +316,23 @@
 		goto err_free;
 
 	*srq->db = 0;
+#else
+	/*
+	 * Solaris SRQ WQE memory is supplied by the kernel; we'll update
+	 * these after the creation.
+	 */
+	srq->buf.buf      = NULL;
+	srq->buf.length   = 0;
+	srq->db           = NULL;
+
+	/*
+	 * Need solaris to allocate space for the spare WR in
+	 * the list that makes the queue work. The Solaris driver
+	 * will round up to the nearest power of 2 as align_queue_size()
+	 * does for OFED.
+	 */
+	attr_ex->attr.max_wr += 1;
+#endif
 
 	cmd.buf_addr = (uintptr_t) srq->buf.buf;
 	cmd.db_addr  = (uintptr_t) srq->db;
diff -r 428f909809d3 src/verbs.c
--- a/src/verbs.c	Wed Oct 14 12:54:37 2015 -0700
+++ b/src/verbs.c	Fri Nov 13 00:56:50 2015 -0800
@@ -56,6 +56,14 @@
 	if (ret)
 		return ret;
 
+#if defined(__SVR4) && defined(__sun)
+	/*
+	 * To be consistent with OFED and so the queue operations in srq.c work
+	 * we need to report the max as actual max  less 1. In OFED this is
+	 * done in the HCA driver.
+	 */
+	attr->max_srq_wr -=1;
+#endif
 	major     = (raw_fw_ver >> 32) & 0xffff;
 	minor     = (raw_fw_ver >> 16) & 0xffff;
 	sub_minor = raw_fw_ver & 0xffff;
@@ -197,6 +205,9 @@
 	struct mlx4_cq		  *cq;
 	int			   ret;
 	struct mlx4_context       *mctx = to_mctx(context);
+#if defined(__SVR4) && defined(__sun)
+	void                      *cqbuf;
+#endif
 
 	/* Sanity check CQ size before proceeding */
 	if (cqe > 0x3fffff)
@@ -213,6 +224,7 @@
 
 	cqe = align_queue_size(cqe + 1);
 
+#if !(defined(__SVR4) && defined(__sun))
 	if (mlx4_alloc_cq_buf(to_mdev(context->device), &cq->buf, cqe, mctx->cqe_size))
 		goto err;
 
@@ -228,15 +240,75 @@
 
 	cmd.buf_addr = (uintptr_t) cq->buf.buf;
 	cmd.db_addr  = (uintptr_t) cq->set_ci_db;
+#else
+	cq->cqe_size   = mctx->cqe_size;
+	cq->buf.buf    = NULL;
+	cq->buf.length = 0;
+	cq->arm_db     = NULL;
+	cq->set_ci_db  = NULL;
+#endif
 
 	ret = ibv_cmd_create_cq(context, cqe - 1, channel, comp_vector,
 				&cq->ibv_cq, &cmd.ibv_cmd, sizeof cmd,
 				&resp.ibv_resp, sizeof resp);
 	if (ret)
+#if !(defined(__SVR4) && defined(__sun))
 		goto err_db;
 
 	cq->cqn = resp.cqn;
+#else
+		goto err;
 
+        /*
+         * For Solaris the kernel driver passes back mmap information for
+	 *  mapping the CQ memory it allocated.
+         */
+	if (resp.mdd.mcq_rev < MLNX_UMAP_IF_VERSION) {
+		fprintf(stderr, PFX "libmlx4_create_cq: libmlx4/hermon umap "
+		    "rev mismatch (kernel rev=%d)\n", resp.mdd.mcq_rev);
+		goto err_destroy;
+	}
+
+        cqbuf = mmap64((void *)0, resp.mdd.mcq_maplen, (PROT_READ | PROT_WRITE),
+	    MAP_SHARED, context->mmap_fd, resp.mdd.mcq_mapoffset);
+
+        if (cqbuf == MAP_FAILED)
+                goto err_destroy;
+
+        /*
+         * Extract hardware driver values for the number of CQEs and the
+	 * hardware CQ number to use (needed for user space doorbells).
+         */
+	cqe            = resp.mdd.mcq_numcqe;
+	cq->cqn        = resp.mdd.mcq_cqnum;
+	cq->buf.buf    = cqbuf;
+	cq->buf.length = resp.mdd.mcq_maplen;
+	cq->ibv_cq.cqe = cqe-1;
+
+	/*
+	 * We map both poll and arm as seperate doorbells (OFED assumes 1 word
+	 * offset and just bumps the address) since Solaris provides a
+	 * separate offst. This will amount to the same thing (a second
+	 * reference to the first doorbell is added) but is more flexible.
+	 */
+	cq->set_ci_db = mlx4_alloc_db(to_mctx(context),
+	    resp.mdd.mcq_polldbr_mapoffset, resp.mdd.mcq_polldbr_maplen,
+	    resp.mdd.mcq_polldbr_offset);
+
+        if (cq->set_ci_db == NULL)
+                goto err_buf;
+
+	cq->arm_db = mlx4_alloc_db(to_mctx(context),
+	    resp.mdd.mcq_armdbr_mapoffset, resp.mdd.mcq_armdbr_maplen,
+	    resp.mdd.mcq_armdbr_offset);
+
+        if (cq->arm_db == NULL)
+                goto err_db;
+
+	*cq->arm_db    = 0;
+	cq->arm_sn     = 1;
+	*cq->set_ci_db = 0;
+#endif
 	return &cq->ibv_cq;
 
 err_db:
@@ -245,6 +317,21 @@
 err_buf:
 	mlx4_free_buf(&cq->buf);
 
+#if defined(__SVR4) && defined(__sun)
+err_destroy:
+	/*
+	 * Calling ibv_cmd_destroy_cq() will try and take the ibv_cq
+	 * mutext that is initialised by the ibv_create_cq() entry point
+	 * that called us AFETR we return, so its not initialised yet.
+	 * So initialised it here so the destroy call doesn't hang.
+	 */
+	pthread_mutex_init(&(cq->ibv_cq.mutex), NULL);
+	pthread_cond_init(&(cq->ibv_cq.cond), NULL);
+	cq->ibv_cq.comp_events_completed = 0;
+	cq->ibv_cq.async_events_completed = 0;
+
+	ibv_cmd_destroy_cq(&cq->ibv_cq);
+#endif
 err:
 	free(cq);
 
@@ -255,10 +342,14 @@
 {
 	struct mlx4_cq *cq = to_mcq(ibcq);
 	struct mlx4_resize_cq cmd;
-	struct ibv_resize_cq_resp resp;
 	struct mlx4_buf buf;
 	int old_cqe, outst_cqe, ret;
-
+#if !(defined(__SVR4) && defined(__sun))
+	struct ibv_resize_cq_resp resp;
+#else
+	struct mlx4_resize_cq_resp	resp;
+	void				*cqbuf;
+#endif
 	/* Sanity check CQ size before proceeding */
 	if (cqe > 0x3fffff)
 		return EINVAL;
@@ -278,25 +369,75 @@
 		goto out;
 	}
 
+#if !(defined(__SVR4) && defined(__sun))
 	ret = mlx4_alloc_cq_buf(to_mdev(ibcq->context->device), &buf, cqe, cq->cqe_size);
 	if (ret)
 		goto out;
-
-	old_cqe = ibcq->cqe;
 	cmd.buf_addr = (uintptr_t) buf.buf;
+#endif
+        old_cqe = ibcq->cqe;
 
 	ret = ibv_cmd_resize_cq(ibcq, cqe - 1, &cmd.ibv_cmd, sizeof cmd,
-				&resp, sizeof resp);
-	if (ret) {
-		mlx4_free_buf(&buf);
+#if !(defined(__SVR4) && defined(__sun))
+					&resp, sizeof resp);
+#else
+					&resp.ibv_resp, sizeof resp);
+#endif
+
+        if (ret) {
+#if !(defined(__SVR4) && defined(__sun))
+                mlx4_free_buf(&buf);
 		goto out;
 	}
 
 	mlx4_cq_resize_copy_cqes(cq, buf.buf, old_cqe);
+        mlx4_free_buf(&cq->buf);
+        cq->buf = buf;
+#else
+		goto out;
+	}
+        if (cq->buf.buf != NULL) {
+        	buf.buf = malloc(cq->buf.length);
+        	if (!buf.buf) {
+                	ret = ENOMEM;
+                	goto out;
+        	}
 
-	mlx4_free_buf(&cq->buf);
-	cq->buf = buf;
+        	memcpy(buf.buf, cq->buf.buf, cq->buf.length);
+        	buf.length =  cq->buf.length;
+                ret = munmap((char *)cq->buf.buf, cq->buf.length);
+                if (ret) {
+                        free(buf.buf);
+                        goto out;
+                }
+        }
+	/*
+	 * For Solaris the kernel driver passes back mmap information for
+	 * mapping the CQ memory it allocated.
+	 */
+	if (resp.mdd.mcq_rev < MLNX_UMAP_IF_VERSION) {
+		fprintf(stderr, PFX "libmlx4_resize_cq: libmlx4/hermon umap "
+		    "rev mismatch (kernel rev=%d)\n", resp.mdd.mcq_rev);
+		ret = EINVAL;
+		goto out;
+	}
 
+	cqbuf = mmap64((void *)0, resp.mdd.mcq_maplen, (PROT_READ | PROT_WRITE),
+	     MAP_SHARED, ibcq->context->mmap_fd, resp.mdd.mcq_mapoffset);
+
+	if (cqbuf == MAP_FAILED) {
+		ret = EINVAL;
+		goto out;
+	}
+	cq->buf.buf    = buf.buf;
+	cq->buf.length = buf.length;
+	mlx4_cq_resize_copy_cqes(cq, cqbuf, old_cqe);
+	cq->buf.buf    = cqbuf;
+	cq->buf.length = resp.mdd.mcq_maplen;
+	free(buf.buf);
+	cq->ibv_cq.cqe =  resp.mdd.mcq_numcqe - 1;
+	cq->cqn        = resp.mdd.mcq_cqnum;
+#endif
 out:
 	pthread_spin_unlock(&cq->lock);
 	return ret;
@@ -311,6 +452,9 @@
 		return ret;
 
 	mlx4_free_db(to_mctx(cq->context), MLX4_DB_TYPE_CQ, to_mcq(cq)->set_ci_db);
+#if defined(__SVR4) && defined(__sun)
+	mlx4_free_db(to_mctx(cq->context), MLX4_DB_TYPE_CQ, to_mcq(cq)->arm_db);
+#endif
 	mlx4_free_buf(&to_mcq(cq)->buf);
 	free(to_mcq(cq));
 
@@ -324,6 +468,9 @@
 	struct mlx4_create_srq_resp resp;
 	struct mlx4_srq		   *srq;
 	int			    ret;
+#if defined(__SVR4) && defined(__sun)
+	void                       *srqbuf;
+#endif
 
 	/* Sanity check SRQ size before proceeding */
 	if (attr->attr.max_wr > 1 << 16 || attr->attr.max_sge > 64)
@@ -336,6 +483,7 @@
 	if (pthread_spin_init(&srq->lock, PTHREAD_PROCESS_PRIVATE))
 		goto err;
 
+#if !(defined(__SVR4) && defined(__sun))
 	srq->max     = align_queue_size(attr->attr.max_wr + 1);
 	srq->max_gs  = attr->attr.max_sge;
 	srq->counter = 0;
@@ -352,21 +500,117 @@
 
 	cmd.buf_addr = (uintptr_t) srq->buf.buf;
 	cmd.db_addr  = (uintptr_t) srq->db;
+#else
+	/*
+	 * Solaris SRQ WQE memory is supplied by the kernel; we'll update
+	 * these after the creation.
+	 */
+	srq->buf.buf      = NULL;
+	srq->buf.length   = 0;
+	srq->db           = NULL;
+	srq->ext_srq	  = 0;
+
+	/*
+	 * Need solaris to allocate space for the spare WR in
+	 * the list that makes the queue work. The Solaris driver
+	 * will round up to the nearest power of 2 as align_queue_size()
+	 * does for OFED.
+	 */
+	attr->attr.max_wr += 1;
+#endif
 
 	ret = ibv_cmd_create_srq(pd, &srq->verbs_srq.srq, attr,
 				 &cmd.ibv_cmd, sizeof cmd,
 				 &resp.ibv_resp, sizeof resp);
+#if defined(__SVR4) && defined(__sun)
+	if (ret) {
+		goto err;
+	}
+
+        /*
+         * The kernel driver passes back mmap information for mapping the
+         * SRQ work queue memory it allocated and the doorbell for
+	 * for posting.
+         */
+	if (resp.mdd.msrq_rev < 1) {
+		fprintf(stderr, PFX "libmlx4_create_srq libmlx4/hermon umap "
+			"rev mismatch (kernel rev=%d)\n", resp.mdd.msrq_rev);
+		goto err_destroy;
+	}
+
+        srqbuf = mmap64((void *)0, resp.mdd.msrq_maplen,
+	    (PROT_READ | PROT_WRITE), MAP_SHARED, pd->context->mmap_fd,
+	    resp.mdd.msrq_mapoffset);
+
+        if (srqbuf == MAP_FAILED) {
+                goto err_destroy;
+        }
+
+	srq->buf.buf    = srqbuf;
+	srq->buf.length = resp.mdd.msrq_maplen;
+	srq->max	= resp.ibv_resp.max_wr;
+	srq->max_gs	= resp.ibv_resp.max_sge;
+	srq->srqn       = resp.mdd.msrq_srqnum;
+	srq->counter 	= 0;
+
+	srq->db = mlx4_alloc_db(to_mctx(pd->context),
+	    resp.mdd.msrq_rdbr_mapoffset, resp.mdd.msrq_rdbr_maplen,
+	    resp.mdd.msrq_rdbr_offset);
+	if (srq->db == NULL) {
+                goto err_unmap;
+	}
+
+	/*
+	 * The following call only initializes memory and control structures,
+	 * it utilizes the memory allocated by the kernel.
+	 * It also allocates the srq->wrid memory.
+	 */
+	if (mlx4_set_srq_buf(pd, srq, resp.mdd.msrq_wqesz,
+	    resp.mdd.msrq_numwqe)) {
+		goto err_db;
+	}
+
+	/*
+	 * The rturned max wr will have been rounded up to the nearest
+	 * power of 2, subtracting  1 from that and rporting that value
+	 * as the max will give us the required free WR in the queue, as
+	 * in OFED.
+	 */
+	attr->attr.max_wr -= 1;
+#else
 	if (ret)
 		goto err_db;
 
+#endif
 	return &srq->verbs_srq.srq;
 
 err_db:
 	mlx4_free_db(to_mctx(pd->context), MLX4_DB_TYPE_RQ, srq->db);
 
+#if defined(__SVR4) && defined(__sun)
+	if (srq->wrid)
+		free(srq->wrid);
+err_unmap:
+	mlx4_free_buf(&srq->buf);
+
+err_destroy:
+	/*
+	 * Calling ibv_cmd_destroy_srq() will try and take the ibv_srq
+	 * mutext that is initialised by the ibv_create_srq() entry point
+	 * that called us AFETR we return, so its not initialised yet.
+	 * So initialised it here so the destroy call doesn't hang.
+	 */
+	pthread_mutex_init(&(srq->verbs_srq.srq.mutex), NULL);
+	pthread_cond_init(&(srq->verbs_srq.srq.cond), NULL);
+	srq->verbs_srq.srq.events_completed = 0;
+
+	ibv_cmd_destroy_srq(&srq->verbs_srq.srq);
+
+#else
 err_free:
 	free(srq->wrid);
 	mlx4_free_buf(&srq->buf);
+#endif
 
 err:
 	free(srq);
@@ -392,7 +636,16 @@
 {
 	struct ibv_modify_srq cmd;
 
+#if !(defined(__SVR4) && defined(__sun))
 	return ibv_cmd_modify_srq(srq, attr, attr_mask, &cmd, sizeof cmd);
+#else
+	int	ret;
+
+	attr->max_wr += 1;		/* See create_srq */
+	ret = ibv_cmd_modify_srq(srq, attr, attr_mask, &cmd, sizeof cmd);
+	attr->max_wr -= 1;
+	return (ret);
+#endif
 }
 
 int mlx4_query_srq(struct ibv_srq *srq,
@@ -400,7 +653,17 @@
 {
 	struct ibv_query_srq cmd;
 
+#if !(defined(__SVR4) && defined(__sun))
 	return ibv_cmd_query_srq(srq, attr, &cmd, sizeof cmd);
+#else
+
+	int	ret;
+
+	ret = ibv_cmd_query_srq(srq, attr, &cmd, sizeof cmd);
+	attr->max_wr -= 1;		/* See create_srq */
+
+	return (ret);
+#endif
 }
 
 int mlx4_destroy_srq(struct ibv_srq *srq)
@@ -426,9 +689,14 @@
 				 struct ibv_qp_init_attr_ex *attr)
 {
 	struct mlx4_create_qp     cmd;
-	struct ibv_create_qp_resp resp;
 	struct mlx4_qp		 *qp;
 	int			  ret;
+#if !(defined(__SVR4) && defined(__sun))
+	struct ibv_create_qp_resp resp;
+#else
+	struct mlx4_create_qp_resp	resp;
+	void				*qpbuf;
+#endif
 
 	/* Sanity check QP size before proceeding */
 	if (attr->cap.max_send_wr     > 65536 ||
@@ -445,6 +713,7 @@
 	if (attr->qp_type == IBV_QPT_XRC_RECV) {
 		attr->cap.max_send_wr = qp->sq.wqe_cnt = 0;
 	} else {
+#if !(defined(__SVR4) && defined(__sun))
 		mlx4_calc_sq_wqe_size(&attr->cap, attr->qp_type, qp);
 		/*
 		 * We need to leave 2 KB + 1 WQE of headroom in the SQ to
@@ -452,19 +721,38 @@
 		 */
 		qp->sq_spare_wqes = (2048 >> qp->sq.wqe_shift) + 1;
 		qp->sq.wqe_cnt = align_queue_size(attr->cap.max_send_wr + qp->sq_spare_wqes);
+#endif
 	}
 
 	if (attr->srq || attr->qp_type == IBV_QPT_XRC_SEND ||
 	    attr->qp_type == IBV_QPT_XRC_RECV) {
 		attr->cap.max_recv_wr = qp->rq.wqe_cnt = attr->cap.max_recv_sge = 0;
 	} else {
+#if !(defined(__SVR4) && defined(__sun))
 		qp->rq.wqe_cnt = align_queue_size(attr->cap.max_recv_wr);
+#endif
 		if (attr->cap.max_recv_sge < 1)
 			attr->cap.max_recv_sge = 1;
 		if (attr->cap.max_recv_wr < 1)
 			attr->cap.max_recv_wr = 1;
 	}
 
+#if defined(__SVR4) && defined(__sun)
+	if (pthread_spin_init(&qp->sq.lock, PTHREAD_PROCESS_PRIVATE) ||
+	    pthread_spin_init(&qp->rq.lock, PTHREAD_PROCESS_PRIVATE))
+		goto err;
+
+	/*
+	 * Solaris QP work queue memory is supplied by the kernel, so
+	 * we will update this after creation.
+	 */
+	qp->buf.buf	= NULL;
+	qp->sq.wrid	= NULL;
+	qp->rq.wrid	= NULL;
+	qp->buf.length	= 0;
+	qp->db		= NULL;
+	memset(&cmd, 0, sizeof(cmd));
+#else
 	if (mlx4_alloc_qp_buf(context, &attr->cap, attr->qp_type, qp))
 		goto err;
 
@@ -493,12 +781,15 @@
 		; /* nothing */
 	cmd.sq_no_prefetch = 0;	/* OK for ABI 2: just a reserved field */
 	memset(cmd.reserved, 0, sizeof cmd.reserved);
+#endif
 
 	pthread_mutex_lock(&to_mctx(context)->qp_table_mutex);
 
 	ret = ibv_cmd_create_qp_ex(context, &qp->verbs_qp,
-				   sizeof(qp->verbs_qp), attr,
-				   &cmd.ibv_cmd, sizeof cmd, &resp, sizeof resp);
+				sizeof(qp->verbs_qp), attr,
+				&cmd.ibv_cmd, sizeof cmd,
+#if !(defined(__SVR4) && defined(__sun))
+				&resp, sizeof resp);
 	if (ret)
 		goto err_rq_db;
 
@@ -507,6 +798,70 @@
 		if (ret)
 			goto err_destroy;
 	}
+#else
+				&resp.ibv_resp, sizeof resp);
+	if (ret)
+		goto err_free;
+
+        /*
+         * The kernel driver passes back mmap information for mapping the
+         * QP work queue memory it allocated back into user space.
+         */
+	if (resp.mdd.mqp_rev < 2) {
+		fprintf(stderr, PFX "libmlx4_create_qp: libmlx4/hermon umap "
+		    "rev mismatch (kernel rev=%d)\n", resp.mdd.mqp_rev);
+		goto err_destroy;
+	}
+	qpbuf = mmap64((void *)0, resp.mdd.mqp_maplen, (PROT_READ | PROT_WRITE),
+	    MAP_SHARED, context->mmap_fd, resp.mdd.mqp_mapoffset);
+
+	if (qpbuf == MAP_FAILED)
+		goto err_destroy;
+
+	/*
+	 * Need to set qp->buf here in case alloc_db fails then
+	 * we'll call mlx4_free_buf() to umap.
+	 */
+	qp->buf.buf	= qpbuf;
+	qp->buf.length	= resp.mdd.mqp_maplen;
+
+	if (attr->cap.max_recv_sge) {
+		qp->db = mlx4_alloc_db(to_mctx(context),
+		    resp.mdd.mqp_rdbr_mapoffset, resp.mdd.mqp_rdbr_maplen,
+		    resp.mdd.mqp_rdbr_offset);
+		if (qp->db == NULL)
+			goto err_buf;
+
+		*qp->db = 0;
+	}
+
+	/*
+	 * Retrieve sendqueue actual size, and the number of headroom WQEs
+	 * that were required based on kernel setup of prefetch or not for
+	 * send queue.
+	 * 	Note: mqp_sq_numwqe includes the head room wqes. The private
+	 *	      wqe.cnt also includes headroom wqes, the verbs count
+	 *	      should reflect the wqe count that is usable.
+	 */
+	qp->sq_spare_wqes = resp.mdd.mqp_sq_headroomwqes;
+	qp->sq.wqe_cnt    = resp.mdd.mqp_sq_numwqe;
+
+	if (attr->srq)
+		qp->rq.wqe_cnt  = 0;
+	else
+		qp->rq.wqe_cnt  = resp.mdd.mqp_rq_numwqe;
+
+	if (mlx4_set_qp_buf(attr->pd, qp, qpbuf, resp.mdd.mqp_maplen,
+	    resp.mdd.mqp_rq_wqesz, resp.mdd.mqp_rq_off,
+	    resp.mdd.mqp_sq_wqesz, resp.mdd.mqp_sq_off))
+		goto err_rq_db;
+
+	mlx4_init_qp_indices(qp);
+
+	ret = mlx4_store_qp(to_mctx(context), qp->verbs_qp.qp.qp_num, qp);
+	if (ret)
+		goto err_rq_db;
+#endif
 	pthread_mutex_unlock(&to_mctx(context)->qp_table_mutex);
 
 	qp->rq.wqe_cnt = qp->rq.max_post = attr->cap.max_recv_wr;
@@ -522,6 +877,35 @@
 
 	return &qp->verbs_qp.qp;
 
+#if defined(__SVR4) && defined(__sun)
+err_rq_db:
+	if (attr->cap.max_recv_sge)
+		mlx4_free_db(to_mctx(context), MLX4_DB_TYPE_RQ, qp->db);
+err_buf:
+	mlx4_free_buf(&qp->buf);
+
+err_destroy:
+	/*
+	 * Calling ibv_cmd_destroy_qp() will try and take the ibv_qp
+	 * mutext that is initialised by the ibv_create_qp() entry point
+	 * that called us AFETR we retrun, so its not initialised yet.
+	 * So initialised it here so the destroy call doesn't hang.
+	 */
+	pthread_mutex_init(&(qp->verbs_qp.qp.mutex), NULL);
+	pthread_cond_init(&(qp->verbs_qp.qp.cond), NULL);
+	qp->verbs_qp.qp.events_completed = 0;
+	ibv_cmd_destroy_qp(&qp->verbs_qp.qp);
+err_free:
+	pthread_mutex_unlock(&to_mctx(context)->qp_table_mutex);
+
+	if (qp->sq.wrid)
+		free(qp->sq.wrid);
+
+	if (qp->rq.wrid)
+		free(qp->rq.wrid);
+err:
+	free(qp);
+#else
 err_destroy:
 	ibv_cmd_destroy_qp(&qp->verbs_qp.qp);
 
@@ -538,6 +922,7 @@
 
 err:
 	free(qp);
+#endif
 
 	return NULL;
 }
