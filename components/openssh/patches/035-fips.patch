#
# Limit ciphers and MACs in algorithm negotiation proposal,
# when underlying libcrypto is FIPS capable.
#
# This patch is unlikely to be accepted upstream.
#
--- old/cipher.c	2022-10-18 09:16:38.355849456 +0200
+++ new/cipher.c	2022-10-18 09:17:24.960709838 +0200
@@ -83,7 +83,43 @@ struct sshcipher {
 #endif
 };
 
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit ciphers to FIPS compliant only */
+#define	ciphers (ssh_FIPS_mode() ? ciphers_fips : ciphers_dflt)
+
+static const struct sshcipher ciphers_fips[] = {
+#ifdef WITH_OPENSSL
+#ifndef OPENSSL_NO_DES
+	{ "3des-cbc",		8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },
+#endif
+	{ "aes128-cbc",		16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },
+	{ "aes192-cbc",		16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },
+	{ "aes256-cbc",		16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },
+	{ "rijndael-cbc@lysator.liu.se",
+				16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },
+	{ "aes128-ctr",		16, 16, 0, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		16, 24, 0, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		16, 32, 0, 0, 0, EVP_aes_256_ctr },
+# ifdef OPENSSL_HAVE_EVPGCM
+	{ "aes128-gcm@openssh.com",
+				16, 16, 12, 16, 0, EVP_aes_128_gcm },
+	{ "aes256-gcm@openssh.com",
+				16, 32, 12, 16, 0, EVP_aes_256_gcm },
+# endif /* OPENSSL_HAVE_EVPGCM */
+#else
+	{ "aes128-ctr",		16, 16, 0, 0, CFLAG_AESCTR, NULL },
+	{ "aes192-ctr",		16, 24, 0, 0, CFLAG_AESCTR, NULL },
+	{ "aes256-ctr",		16, 32, 0, 0, CFLAG_AESCTR, NULL },
+#endif
+	{ "none",		8, 0, 0, 0, CFLAG_NONE, NULL },
+
+	{ NULL,			0, 0, 0, 0, 0, NULL }
+};
+
+static const struct sshcipher ciphers_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 static const struct sshcipher ciphers[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 #ifdef WITH_OPENSSL
 #ifndef OPENSSL_NO_DES
 	{ "3des-cbc",		8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },
--- old/digest-openssl.c	2022-10-18 09:16:38.360996604 +0200
+++ new/digest-openssl.c	2022-10-18 09:17:24.965809214 +0200
@@ -31,6 +31,7 @@
 #include "sshbuf.h"
 #include "digest.h"
 #include "ssherr.h"
+#include "misc.h"
 
 #ifndef HAVE_EVP_SHA256
 # define EVP_sha256 NULL
@@ -54,8 +55,21 @@ struct ssh_digest {
 	const EVP_MD *(*mdfunc)(void);
 };
 
+#ifdef ENABLE_OPENSSL_FIPS
 /* NB. Indexed directly by algorithm number */
+const struct ssh_digest digests_fips[] = {
+	{ SSH_DIGEST_MD5,	"",	 	16,	NULL },
+	{ SSH_DIGEST_SHA1,	"SHA1",	 	20,	EVP_sha1 },
+	{ SSH_DIGEST_SHA256,	"SHA256", 	32,	EVP_sha256 },
+	{ SSH_DIGEST_SHA384,	"SHA384",	48,	EVP_sha384 },
+	{ SSH_DIGEST_SHA512,	"SHA512", 	64,	EVP_sha512 },
+	{ -1,			NULL,		0,	NULL },
+};
+/* NB. Indexed directly by algorithm number */
+const struct ssh_digest digests_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 const struct ssh_digest digests[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 	{ SSH_DIGEST_MD5,	"MD5",	 	16,	EVP_md5 },
 	{ SSH_DIGEST_SHA1,	"SHA1",	 	20,	EVP_sha1 },
 	{ SSH_DIGEST_SHA256,	"SHA256", 	32,	EVP_sha256 },
@@ -67,6 +81,9 @@ const struct ssh_digest digests[] = {
 static const struct ssh_digest *
 ssh_digest_by_alg(int alg)
 {
+#ifdef ENABLE_OPENSSL_FIPS
+	struct ssh_digest *digests = ssh_FIPS_mode() ? digests_fips : digests_dflt;
+#endif
 	if (alg < 0 || alg >= SSH_DIGEST_MAX)
 		return NULL;
 	if (digests[alg].id != alg) /* sanity */
@@ -79,6 +96,9 @@ ssh_digest_by_alg(int alg)
 int
 ssh_digest_alg_by_name(const char *name)
 {
+#ifdef ENABLE_OPENSSL_FIPS
+	struct ssh_digest *digests = ssh_FIPS_mode() ? digests_fips : digests_dflt;
+#endif
 	int alg;
 
 	for (alg = 0; digests[alg].id != -1; alg++) {
--- old/kex.c	2022-10-18 09:16:38.366113315 +0200
+++ new/kex.c	2022-10-27 09:05:33.131356499 +0200
@@ -90,6 +90,7 @@ struct kexalg {
 	int ec_nid;
 	int hash_alg;
 };
+
 static const struct kexalg kexalgs[] = {
 #ifdef WITH_OPENSSL
 	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
@@ -1242,10 +1243,18 @@ kex_exchange_identification(struct ssh *
 	sshbuf_reset(our_version);
 	if (version_addendum != NULL && *version_addendum == '\0')
 		version_addendum = NULL;
+#ifdef ENABLE_OPENSSL_FIPS
+	if ((r = sshbuf_putf(our_version, "SSH-%d.%d-%.100s%s%s%s\r\n",
+	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,
+	    ssh_FIPS_mode() ? " FIPS" : "",
+	    version_addendum == NULL ? "" : " ",
+	    version_addendum == NULL ? "" : version_addendum)) != 0) {
+#else
 	if ((r = sshbuf_putf(our_version, "SSH-%d.%d-%.100s%s%s\r\n",
 	   PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,
 	    version_addendum == NULL ? "" : " ",
 	    version_addendum == NULL ? "" : version_addendum)) != 0) {
+#endif
 		oerrno = errno;
 		error("%s: sshbuf_putf: %s", __func__, ssh_err(r));
 		goto out;
--- old/mac.c	2022-10-18 09:16:38.371111092 +0200
+++ new/mac.c	2022-10-18 09:17:24.984257758 +0200
@@ -55,8 +55,33 @@ struct macalg {
 	int		len;		/* just for UMAC */
 	int		etm;		/* Encrypt-then-MAC */
 };
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit macs to FIPS compliant only */
+#define	macs (ssh_FIPS_mode() ? macs_fips : macs_dflt)
 
+static const struct macalg macs_fips[] = {
+	/* Encrypt-and-MAC (encrypt-and-authenticate) variants */
+	{ "hmac-sha1",				SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },
+	{ "hmac-sha1-96",			SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },
+#ifdef HAVE_EVP_SHA256
+	{ "hmac-sha2-256",			SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },
+	{ "hmac-sha2-512",			SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },
+#endif
+	/* Encrypt-then-MAC variants */
+	{ "hmac-sha1-etm@openssh.com",		SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },
+	{ "hmac-sha1-96-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },
+#ifdef HAVE_EVP_SHA256
+	{ "hmac-sha2-256-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },
+	{ "hmac-sha2-512-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },
+#endif
+
+	{ NULL,					0, 0, 0, 0, 0, 0 }
+};
+
+static const struct macalg macs_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 static const struct macalg macs[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 	/* Encrypt-and-MAC (encrypt-and-authenticate) variants */
 	{ "hmac-sha1",				SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },
 	{ "hmac-sha1-96",			SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },
--- old/misc.c	2022-10-18 09:16:38.376178017 +0200
+++ new/misc.c	2022-10-26 11:57:41.322486312 +0200
@@ -42,6 +42,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <dlfcn.h>
 
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
@@ -49,6 +50,10 @@
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -85,6 +90,28 @@ chop(char *s)
 
 }
 
+#ifdef ENABLE_OPENSSL_FIPS
+/* is OpenSSL FIPS mode set? */
+int
+ssh_FIPS_mode()
+{
+	return (EVP_default_properties_is_fips_enabled(NULL));
+}
+
+/*
+ * Check and display FIPS mode status. 
+ */
+void 
+ssh_FIPS_check_status()
+{
+	if (ssh_FIPS_mode()) {
+		debug("Running in FIPS mode.");
+	} else {
+		debug("Running in non-FIPS mode.");
+	}
+}
+#endif
+
 /* set/unset filedescriptor to non-blocking */
 int
 set_nonblock(int fd)
--- old/misc.h	2022-10-18 09:16:38.381101961 +0200
+++ new/misc.h	2022-10-18 09:17:24.994547005 +0200
@@ -47,6 +47,10 @@ char	*chop(char *);
 void	skip_space(char **);
 char	*strdelim(char **);
 char	*strdelimw(char **);
+#ifdef ENABLE_OPENSSL_FIPS
+int	 ssh_FIPS_mode();
+void     ssh_FIPS_check_status();
+#endif
 int	 set_nonblock(int);
 int	 unset_nonblock(int);
 void	 set_nodelay(int);
--- old/myproposal.h	2022-10-18 09:16:38.386074640 +0200
+++ new/myproposal.h	2022-10-26 13:05:06.448640988 +0200
@@ -24,7 +24,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#define KEX_SERVER_KEX	\
+#define KEX_SERVER_KEX_DFLT \
 	"curve25519-sha256," \
 	"curve25519-sha256@libssh.org," \
 	"ecdh-sha2-nistp256," \
@@ -35,9 +35,26 @@
 	"diffie-hellman-group18-sha512," \
 	"diffie-hellman-group14-sha256"
 
-#define KEX_CLIENT_KEX KEX_SERVER_KEX
+#define KEX_CLIENT_KEX_DFLT KEX_SERVER_KEX_DFLT
 
-#define	KEX_DEFAULT_PK_ALG	\
+#define KEX_COMMON_KEX_FIPS \
+	"curve25519-sha256," \
+	"curve25519-sha256@libssh.org," \
+	"ecdh-sha2-nistp256," \
+	"ecdh-sha2-nistp384," \
+	"ecdh-sha2-nistp521," \
+	"diffie-hellman-group-exchange-sha256," \
+	"diffie-hellman-group16-sha512," \
+	"diffie-hellman-group18-sha512,"
+
+#define KEX_SERVER_KEX_FIPS KEX_COMMON_KEX_FIPS \
+	"diffie-hellman-group14-sha1" \
+
+#define KEX_CLIENT_KEX_FIPS KEX_COMMON_KEX_FIPS \
+	"diffie-hellman-group-exchange-sha1," \
+	"diffie-hellman-group14-sha1"
+
+#define	KEX_DEFAULT_PK_ALG_DFLT	\
 	"ecdsa-sha2-nistp256-cert-v01@openssh.com," \
 	"ecdsa-sha2-nistp384-cert-v01@openssh.com," \
 	"ecdsa-sha2-nistp521-cert-v01@openssh.com," \
@@ -57,14 +74,39 @@
 	"rsa-sha2-256," \
 	"ssh-rsa"
 
-#define	KEX_SERVER_ENCRYPT \
+#define	KEX_DEFAULT_PK_ALG_FIPS \
+	"ecdsa-sha2-nistp256-cert-v01@openssh.com," \
+	"ecdsa-sha2-nistp384-cert-v01@openssh.com," \
+	"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com," \
+	"ssh-ed25519-cert-v01@openssh.com," \
+	"sk-ssh-ed25519-cert-v01@openssh.com," \
+	"ssh-rsa-cert-v01@openssh.com," \
+	"ecdsa-sha2-nistp256," \
+	"ecdsa-sha2-nistp384," \
+	"ecdsa-sha2-nistp521," \
+	"sk-ecdsa-sha2-nistp256@openssh.com," \
+	"ssh-ed25519," \
+	"sk-ssh-ed25519@openssh.com," \
+	"rsa-sha2-512," \
+	"rsa-sha2-256," \
+	"ssh-rsa"
+
+#define KEX_SERVER_ENCRYPT_DFLT \
 	"chacha20-poly1305@openssh.com," \
 	"aes128-ctr,aes192-ctr,aes256-ctr," \
 	"aes128-gcm@openssh.com,aes256-gcm@openssh.com"
 
-#define KEX_CLIENT_ENCRYPT KEX_SERVER_ENCRYPT
+#define KEX_CLIENT_ENCRYPT_DFLT KEX_SERVER_ENCRYPT_DFLT "," \
+	"aes128-cbc,aes192-cbc,aes256-cbc"
+
+#define KEX_SERVER_ENCRYPT_FIPS \
+	"aes128-ctr,aes192-ctr,aes256-ctr," \
+	"aes128-gcm@openssh.com,aes256-gcm@openssh.com"
+
+#define KEX_CLIENT_ENCRYPT_FIPS KEX_SERVER_ENCRYPT_FIPS "," \
+	"aes128-cbc,aes192-cbc,aes256-cbc"
 
-#define	KEX_SERVER_MAC \
+#define KEX_SERVER_MAC_DFLT \
 	"umac-64-etm@openssh.com," \
 	"umac-128-etm@openssh.com," \
 	"hmac-sha2-256-etm@openssh.com," \
@@ -76,7 +118,42 @@
 	"hmac-sha2-512," \
 	"hmac-sha1"
 
-#define KEX_CLIENT_MAC KEX_SERVER_MAC
+#define KEX_CLIENT_MAC_DFLT KEX_SERVER_MAC_DFLT
+
+#define KEX_SERVER_MAC_FIPS \
+	"hmac-sha2-256-etm@openssh.com," \
+	"hmac-sha2-512-etm@openssh.com," \
+	"hmac-sha1-etm@openssh.com," \
+	"hmac-sha2-256," \
+	"hmac-sha2-512," \
+	"hmac-sha1"
+
+#define KEX_CLIENT_MAC_FIPS KEX_SERVER_MAC_FIPS
+
+#ifdef ENABLE_OPENSSL_FIPS
+ #define KEX_SERVER_KEX \
+     (ssh_FIPS_mode() ? (KEX_SERVER_KEX_FIPS) : (KEX_SERVER_KEX_DFLT) )
+ #define KEX_CLIENT_KEX \
+     (ssh_FIPS_mode() ? (KEX_CLIENT_KEX_FIPS) : (KEX_CLIENT_KEX_DFLT) )
+ #define KEX_DEFAULT_PK_ALG \
+     (ssh_FIPS_mode() ? (KEX_DEFAULT_PK_ALG_FIPS) : (KEX_DEFAULT_PK_ALG_DFLT) )
+ #define KEX_SERVER_ENCRYPT \
+    (ssh_FIPS_mode() ? (KEX_SERVER_ENCRYPT_FIPS) : (KEX_SERVER_ENCRYPT_DFLT))
+ #define KEX_CLIENT_ENCRYPT \
+    (ssh_FIPS_mode() ? (KEX_CLIENT_ENCRYPT_FIPS) : (KEX_CLIENT_ENCRYPT_DFLT))
+ #define KEX_SERVER_MAC \
+    (ssh_FIPS_mode() ? (KEX_SERVER_MAC_FIPS) : (KEX_SERVER_MAC_DFLT) )
+ #define KEX_CLIENT_MAC \
+    (ssh_FIPS_mode() ? (KEX_CLIENT_MAC_FIPS) : (KEX_CLIENT_MAC_DFLT) )
+#else /* ENABLE_OPENSSL_FIPS */
+ #define KEX_SERVER_KEX KEX_SERVER_KEX_DFLT
+ #define KEX_CLIENT_KEX KEX_CLIENT_KEX_DFLT
+ #define KEX_DEFAULT_PK_ALG KEX_DEFAULT_PK_ALG_DFLT
+ #define KEX_SERVER_ENCRYPT KEX_SERVER_ENCRYPT_DFLT
+ #define KEX_CLIENT_ENCRYPT KEX_CLIENT_ENCRYPT_DFLT
+ #define KEX_SERVER_MAC KEX_SERVER_MAC_DFLT
+ #define KEX_CLIENT_MAC KEX_CLIENT_MAC_DFLT
+#endif /* ENABLE_OPENSSL_FIPS */
 
 /* Not a KEX value, but here so all the algorithm defaults are together */
 #define	SSH_ALLOWED_CA_SIGALGS	\
--- old/ssh-add.1	2022-10-18 09:16:38.391037460 +0200
+++ new/ssh-add.1	2022-10-18 09:17:25.004598608 +0200
@@ -126,6 +126,8 @@ and
 .Dq sha256 .
 The default is
 .Dq sha256 .
+If OpenSSL is running in FIPS-140 mode, the only supported option is
+.Dq sha256 .
 .It Fl e Ar pkcs11
 Remove keys provided by the PKCS#11 shared library
 .Ar pkcs11 .
--- old/ssh-agent.1	2022-10-18 09:16:38.396306402 +0200
+++ new/ssh-agent.1	2022-10-18 09:17:25.009657146 +0200
@@ -98,6 +98,8 @@ and
 .Dq sha256 .
 The default is
 .Dq sha256 .
+If OpenSSL is running in FIPS-140 mode, the only supported option is
+.Dq sha256 .
 .It Fl k
 Kill the current agent (given by the
 .Ev SSH_AGENT_PID
--- old/ssh-agent.c	2022-10-18 09:16:38.401410448 +0200
+++ new/ssh-agent.c	2022-10-18 09:17:25.014780229 +0200
@@ -1455,6 +1455,9 @@ main(int ac, char **av)
 		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
 		    SSH_AUTHSOCKET_ENV_NAME);
 		printf("echo Agent pid %ld;\n", (long)parent_pid);
+#ifdef ENABLE_OPENSSL_FIPS
+		ssh_FIPS_check_status();
+#endif
 		fflush(stdout);
 		goto skip;
 	}
--- old/ssh-keygen.1	2022-10-18 09:16:38.406488118 +0200
+++ new/ssh-keygen.1	2022-10-26 14:51:39.093176221 +0200
@@ -316,6 +316,8 @@ and
 .Dq sha256 .
 The default is
 .Dq sha256 .
+If OpenSSL is running in FIPS-140 mode, the only supported option is
+.Dq sha256 .
 .It Fl e
 This option will read a private or public OpenSSH key file and
 print to stdout a public key in one of the formats specified by the
--- old/ssh-keygen.c	2022-10-18 09:16:38.411702398 +0200
+++ new/ssh-keygen.c	2022-10-26 13:20:28.324758509 +0200
@@ -1040,7 +1040,12 @@ do_gen_all_hostkeys(struct passwd *pw)
 		char *key_type;
 		char *key_type_display;
 		char *path;
-	} key_types[] = {
+	}
+#ifndef ENABLE_OPENSSL_FIPS
+	key_types[] = {
+#else /* ENABLE_OPENSSL_FIPS */
+	key_types_dflt[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 #ifdef WITH_OPENSSL
 		{ "rsa", "RSA" ,_PATH_HOST_RSA_KEY_FILE },
 		{ "dsa", "DSA", _PATH_HOST_DSA_KEY_FILE },
@@ -1052,8 +1057,22 @@ do_gen_all_hostkeys(struct passwd *pw)
 #ifdef WITH_XMSS
 		{ "xmss", "XMSS",_PATH_HOST_XMSS_KEY_FILE },
 #endif /* WITH_XMSS */
-		{ NULL, NULL, NULL }
-	};
+#ifndef ENABLE_OPENSSL_FIPS
+		{ NULL, NULL, NULL }};
+#else /* ENABLE_OPENSSL_FIPS */
+		{ NULL, NULL, NULL }},
+	key_types_fips[] = {
+#ifdef WITH_OPENSSL
+		{ "rsa", "RSA" ,_PATH_HOST_RSA_KEY_FILE },
+		{ "dsa", "DSA", _PATH_HOST_DSA_KEY_FILE },
+#ifdef OPENSSL_HAS_ECC
+		{ "ecdsa", "ECDSA",_PATH_HOST_ECDSA_KEY_FILE },
+#endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+		{ "ed25519", "ED25519",_PATH_HOST_ED25519_KEY_FILE },
+		{ NULL, NULL, NULL }},
+	*key_types = ssh_FIPS_mode() ? key_types_fips : key_types_dflt;
+#endif /* ENABLE_OPENSSL_FIPS */
 
 	u_int32_t bits = 0;
 	int first = 0;
@@ -3179,6 +3198,10 @@ main(int argc, char **argv)
 
 	log_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
 
+#ifdef ENABLE_OPENSSL_FIPS
+	ssh_FIPS_check_status();
+#endif
+
 	msetlocale();
 
 	/* we need this for the home * directory.  */
--- old/ssh-keysign.c	2022-10-18 09:16:38.416720521 +0200
+++ new/ssh-keysign.c	2022-10-18 09:17:25.039813691 +0200
@@ -219,6 +219,12 @@ main(int argc, char **argv)
 	if (found == 0)
 		fatal("could not open any host key");
 
+#ifdef ENABLE_OPENSSL_FIPS
+#ifdef DEBUG_SSH_KEYSIGN
+	ssh_FIPS_check_status();
+#endif
+#endif
+
 	found = 0;
 	for (i = 0; i < NUM_KEYTYPES; i++) {
 		keys[i] = NULL;
--- old/ssh.1	2022-10-18 09:16:38.422015943 +0200
+++ new/ssh.1	2022-10-18 09:17:25.044950701 +0200
@@ -96,6 +96,9 @@ If a
 is specified,
 it is executed on the remote host instead of a login shell.
 .Pp
+If ssh links with FIPS-capable OpenSSL, ssh runs in FIPS-140 mode.
+In FIPS-140 mode non-FIPS approved ciphers, MACs and digests are disabled.
+.Pp
 The options are as follows:
 .Pp
 .Bl -tag -width Ds -compact
--- old/ssh.c	2022-10-18 09:16:38.427267441 +0200
+++ new/ssh.c	2022-10-18 09:17:25.050074909 +0200
@@ -1183,6 +1183,10 @@ main(int ac, char **av)
 #endif
 		);
 
+#ifdef ENABLE_OPENSSL_FIPS
+	ssh_FIPS_check_status();
+#endif
+
 	/* Parse the configuration files */
 	process_config_files(host_arg, pw, 0, &want_final_pass);
 	if (want_final_pass)
--- old/ssh_api.c	2022-10-18 09:16:38.432629941 +0200
+++ new/ssh_api.c	2022-10-18 09:17:25.055054261 +0200
@@ -92,6 +92,9 @@ ssh_init(struct ssh **sshp, int is_serve
 	int r;
 
 	if (!called) {
+#ifdef ENABLE_OPENSSL_FIPS
+		ssh_FIPS_check_status();
+#endif
 		seed_rng();
 		called = 1;
 	}
--- old/ssh_config.5	2022-10-18 09:16:38.437638079 +0200
+++ new/ssh_config.5	2022-10-18 09:17:25.060354521 +0200
@@ -471,6 +471,13 @@ aes128-ctr,aes192-ctr,aes256-ctr,
 aes128-gcm@openssh.com,aes256-gcm@openssh.com
 .Ed
 .Pp
+The following ciphers are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+aes128-ctr,aes192-ctr,aes256-ctr,
+aes128-gcm@openssh.com,aes256-gcm@openssh.com,
+aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc
+.Ed
+.Pp
 The list of available ciphers may also be obtained using
 .Qq ssh -Q cipher .
 .It Cm ClearAllForwardings
@@ -690,6 +697,8 @@ Valid options are:
 and
 .Cm sha256
 (the default).
+In FIPS-140 mode the only supported option is
+.Dq sha256 .
 .It Cm ForwardAgent
 Specifies whether the connection to the authentication agent (if any)
 will be forwarded to the remote machine.
@@ -799,6 +808,8 @@ Specifies whether key exchange based on
 GSSAPI key exchange the server need not have a host key.
 The default is
 .Cm no .
+.Pp
+GSSAPI key exchange is not available in FIPS-140 mode.
 .It Cm GSSAPIRenewalForcesRekey
 If set to
 .Cm yes
@@ -1277,6 +1288,16 @@ umac-64@openssh.com,umac-128@openssh.com
 hmac-sha2-256,hmac-sha2-512,hmac-sha1
 .Ed
 .Pp
+The following MACs are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+hmac-sha2-256-etm@openssh.com,
+hmac-sha2-512-etm@openssh.com,
+hmac-sha2-256,hmac-sha2-512,
+hmac-sha1-etm@openssh.com,
+hmac-sha1-96-etm@openssh.com
+hmac-sha1,hmac-sha1-96
+.Ed
+.Pp
 The list of available MAC algorithms may also be obtained using
 .Qq ssh -Q mac .
 .It Cm NoHostAuthenticationForLocalhost
@@ -1331,6 +1352,9 @@ The default is:
 publickey,gssapi-keyex,gssapi-with-mic,password,
 keyboard-interactive,hostbased
 .Ed
+.Pp
+.Cm gssapi-keyex
+is not available in FIPS-140 mode.
 .It Cm ProxyCommand
 Specifies the command to use to connect to the server.
 The command
--- old/sshd.8	2022-10-18 09:16:38.442629579 +0200
+++ new/sshd.8	2022-10-18 09:17:25.065619319 +0200
@@ -84,6 +84,9 @@ rereads its configuration file when it r
 by executing itself with the name and options it was started with, e.g.\&
 .Pa /usr/sbin/sshd .
 .Pp
+If sshd links with FIPS-capable OpenSSL, sshd runs in FIPS-140 mode.
+In FIPS-140 mode non-FIPS approved ciphers, MACs and digests are disabled.
+.Pp
 The options are as follows:
 .Bl -tag -width Ds
 .It Fl 4
--- old/sshd.c	2022-10-18 09:16:38.448005023 +0200
+++ new/sshd.c	2022-10-18 09:17:25.070887089 +0200
@@ -1705,6 +1705,10 @@ main(int ac, char **av)
 	    SYSLOG_FACILITY_AUTH : options.log_facility,
 	    log_stderr || !inetd_flag || debug_flag);
 
+#ifdef ENABLE_OPENSSL_FIPS
+	ssh_FIPS_check_status();
+#endif
+
 	/*
 	 * Unset KRB5CCNAME, otherwise the user's session may inherit it from
 	 * root's environment
@@ -2415,10 +2419,15 @@ do_ssh2_kex(struct ssh *ssh)
 	if (strlen(myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]) == 0)
 		orig = NULL;
 
-	if (options.gss_keyex)
-		gss = ssh_gssapi_server_mechanisms();
-	else
-		gss = NULL;
+	if (options.gss_keyex) {
+		if (ssh_FIPS_mode()) {
+			logit("Disabling GSSAPIKeyExchange. Not available"
+			    " in FIPS mode");
+			options.gss_keyex = 0;
+		} else {
+			gss = ssh_gssapi_server_mechanisms();
+		}
+	}
 
 	if (gss && orig)
 		xasprintf(&newstr, "%s,%s", gss, orig);
--- old/sshd_config.5	2022-10-18 09:16:38.453252124 +0200
+++ new/sshd_config.5	2022-10-18 09:17:25.076199522 +0200
@@ -232,6 +232,9 @@ is enabled),
 .Qq password
 and
 .Qq publickey .
+.Pp
+.Qq gssapi-keyex
+is not available in FIPS-140 mode.
 .It Cm AuthorizedKeysCommand
 Specifies a program to be used to look up the user's public keys.
 The program must be owned by root, not writable by group or others and
@@ -492,6 +495,13 @@ aes128-ctr,aes192-ctr,aes256-ctr,
 aes128-gcm@openssh.com,aes256-gcm@openssh.com
 .Ed
 .Pp
+The following ciphers are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+aes128-ctr,aes192-ctr,aes256-ctr,
+aes128-gcm@openssh.com,aes256-gcm@openssh.com,
+aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc
+.Ed
+.Pp
 The list of available ciphers may also be obtained using
 .Qq ssh -Q cipher .
 .It Cm ClientAliveCountMax
@@ -595,6 +605,8 @@ and
 .Cm sha256 .
 The default is
 .Cm sha256 .
+In FIPS-140 mode the only supported option is
+.Dq sha256 .
 .It Cm ForceCommand
 Forces the execution of the command specified by
 .Cm ForceCommand ,
@@ -650,6 +662,8 @@ Specifies whether key exchange based on
 doesn't rely on ssh keys to verify host identity.
 The default is
 .Cm no .
+.Pp
+GSSAPI key exchange is not available in FIPS-140 mode.
 .It Cm GSSAPIStrictAcceptorCheck
 Determines whether to be strict about the identity of the GSSAPI acceptor
 a client authenticates against.
@@ -1124,6 +1138,16 @@ umac-64@openssh.com,umac-128@openssh.com
 hmac-sha2-256,hmac-sha2-512,hmac-sha1
 .Ed
 .Pp
+The following MACs are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+hmac-sha2-256-etm@openssh.com,
+hmac-sha2-512-etm@openssh.com,
+hmac-sha2-256,hmac-sha2-512,
+hmac-sha1-etm@openssh.com,
+hmac-sha1-96-etm@openssh.com
+hmac-sha1,hmac-sha1-96
+.Ed
+.Pp
 The list of available MAC algorithms may also be obtained using
 .Qq ssh -Q mac .
 .It Cm Match
--- old/sshkey.c	2022-10-18 09:16:38.458298797 +0200
+++ new/sshkey.c	2022-10-26 13:23:13.731351619 +0200
@@ -103,7 +103,61 @@ struct keytype {
 	int cert;
 	int sigonly;
 };
+
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit keytypes to FIPS compliant only */
+#define	keytypes (ssh_FIPS_mode() ? keytypes_fips : keytypes_dflt)
+
+static const struct keytype keytypes_fips[] = {
+	{ "ssh-ed25519", "ED25519", NULL, KEY_ED25519, 0, 0, 0 },
+	{ "ssh-ed25519-cert-v01@openssh.com", "ED25519-CERT", NULL,
+	    KEY_ED25519_CERT, 0, 1, 0 },
+	{ "sk-ssh-ed25519@openssh.com", "ED25519-SK", NULL,
+	    KEY_ED25519_SK, 0, 0, 0 },
+	{ "sk-ssh-ed25519-cert-v01@openssh.com", "ED25519-SK-CERT", NULL,
+	    KEY_ED25519_SK_CERT, 0, 1, 0 },
+#ifdef WITH_OPENSSL
+	{ "ssh-rsa", "RSA", NULL, KEY_RSA, 0, 0, 0 },
+	{ "rsa-sha2-256", "RSA", NULL, KEY_RSA, 0, 0, 1 },
+	{ "rsa-sha2-512", "RSA", NULL, KEY_RSA, 0, 0, 1 },
+	{ "ssh-dss", "DSA", NULL, KEY_DSA, 0, 0, 0 },
+# ifdef OPENSSL_HAS_ECC
+	{ "ecdsa-sha2-nistp256", "ECDSA", NULL, KEY_ECDSA, NID_X9_62_prime256v1,
+	    0, 0 },
+	{ "ecdsa-sha2-nistp384", "ECDSA", NULL, KEY_ECDSA, NID_secp384r1,
+	    0, 0 },
+#  ifdef OPENSSL_HAS_NISTP521
+	{ "ecdsa-sha2-nistp521", "ECDSA", NULL, KEY_ECDSA, NID_secp521r1,
+	    0, 0 },
+#  endif /* OPENSSL_HAS_NISTP521 */
+	{ "sk-ecdsa-sha2-nistp256@openssh.com", "ECDSA-SK", NULL,
+	    KEY_ECDSA_SK, NID_X9_62_prime256v1, 0, 0 },
+# endif /* OPENSSL_HAS_ECC */
+	{ "ssh-rsa-cert-v01@openssh.com", "RSA-CERT", NULL, KEY_RSA_CERT,
+	    0, 1, 0 },
+	{ "ssh-dss-cert-v01@openssh.com", "DSA-CERT", NULL, KEY_DSA_CERT,
+	    0, 1, 0 },
+# ifdef OPENSSL_HAS_ECC
+	{ "ecdsa-sha2-nistp256-cert-v01@openssh.com", "ECDSA-CERT", NULL,
+	    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },
+	{ "ecdsa-sha2-nistp384-cert-v01@openssh.com", "ECDSA-CERT", NULL,
+	    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },
+#  ifdef OPENSSL_HAS_NISTP521
+	{ "ecdsa-sha2-nistp521-cert-v01@openssh.com", "ECDSA-CERT", NULL,
+	    KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },
+#  endif /* OPENSSL_HAS_NISTP521 */
+	{ "sk-ecdsa-sha2-nistp256-cert-v01@openssh.com", "ECDSA-SK-CERT", NULL,
+	    KEY_ECDSA_SK_CERT, NID_X9_62_prime256v1, 1, 0 },
+# endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+	{ "null", "null", NULL, KEY_NULL, 0, 0, 0 },
+	{ NULL, NULL, NULL, -1, -1, 0, 0 }
+};
+
+static const struct keytype keytypes_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 static const struct keytype keytypes[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 	{ "ssh-ed25519", "ED25519", NULL, KEY_ED25519, 0, 0, 0 },
 	{ "ssh-ed25519-cert-v01@openssh.com", "ED25519-CERT", NULL,
 	    KEY_ED25519_CERT, 0, 1, 0 },
--- old/sshconnect2.c	2022-10-18 09:16:38.463211151 +0200
+++ new/sshconnect2.c	2022-10-18 09:17:25.086952618 +0200
@@ -262,29 +262,36 @@ ssh_kex2(struct ssh *ssh, char *host, st
 
 #if defined(GSSAPI) && defined(WITH_OPENSSL)
 	if (options.gss_keyex) {
-		/* Add the GSSAPI mechanisms currently supported on this
-		 * client to the key exchange algorithm proposal */
-		orig = myproposal[PROPOSAL_KEX_ALGS];
+		if (ssh_FIPS_mode()) {
+			logit("Disabling GSSAPIKeyExchange. Not available"
+			    " in FIPS mode");
+			options.gss_keyex = 0;
+		} else {
+			/* Add the GSSAPI mechanisms currently supported on this
+			 * client to the key exchange algorithm proposal */
+			orig = myproposal[PROPOSAL_KEX_ALGS];
 
-		if (options.gss_server_identity)
-			gss_host = xstrdup(options.gss_server_identity);
-		else if (options.gss_trust_dns)
-			gss_host = remote_hostname(ssh);
-		else
-			gss_host = xstrdup(host);
+			if (options.gss_server_identity)
+				gss_host = xstrdup(options.gss_server_identity);
+			else if (options.gss_trust_dns)
+				gss_host = remote_hostname(ssh);
+			else
+				gss_host = xstrdup(host);
 
-		gss = ssh_gssapi_client_mechanisms(gss_host,
-		    options.gss_client_identity, options.gss_kex_algorithms);
-		if (gss) {
-			debug("Offering GSSAPI proposal: %s", gss);
-			xasprintf(&myproposal[PROPOSAL_KEX_ALGS],
-			    "%s,%s", gss, orig);
+			gss = ssh_gssapi_client_mechanisms(gss_host,
+			    options.gss_client_identity,
+			    options.gss_kex_algorithms);
+			if (gss) {
+				debug("Offering GSSAPI proposal: %s", gss);
+				xasprintf(&myproposal[PROPOSAL_KEX_ALGS],
+				    "%s,%s", gss, orig);
 
-			/* If we've got GSSAPI algorithms, then we also support the
-			 * 'null' hostkey, as a last resort */
-			orig = myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS];
-			xasprintf(&myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS],
-			    "%s,null", orig);
+				/* If we've got GSSAPI algorithms, then we also
+				 * support the 'null' hostkey, as a last resort */
+				orig = myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS];
+				xasprintf(&myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS],
+				    "%s,null", orig);
+			}
 		}
 	}
 #endif
