This patch has been created by merging upstream changes from
https://sourceforge.net/p/net-snmp/code/ci/2e517c5d60fcf9f96d2ad8045e7aec9b60dec041/ 
with the current codebase.
--- net-snmp-5.8.old/configure
+++ net-snmp-5.8/configure
@@ -7748,8 +7748,8 @@
 fi
 
 
-# Extract the first word of "python", so it can be a program name with args.
-set dummy python; ac_word=$2
+# Extract the first word of "python3", so it can be a program name with args.
+set dummy python3; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
 if ${ac_cv_path_PYTHONPROG+:} false; then :
--- net-snmp-5.8.old/configure.d/config_os_progs
+++ net-snmp-5.8/configure.d/config_os_progs
@@ -57,7 +57,7 @@
 AC_PATH_PROG(AUTOHEADER,  autoheader, [:])
 AC_PATH_PROG([PERLPROG],  perl)
 AC_PATH_PROG([PSPROG],    ps)
-AC_PATH_PROG([PYTHONPROG],python)
+AC_PATH_PROG([PYTHONPROG],python3)
 
 AC_PATH_PROG([UNAMEPROG], uname)
 AC_DEFINE_UNQUOTED(UNAMEPROG,"$UNAMEPROG", [Where is the uname command])
--- net-snmp-5.8.old/python/netsnmp/__init__.py	2018-07-16 07:33:40.000000000 +0000
+++ net-snmp-5.8/python/netsnmp/__init__.py	2020-05-07 02:29:30.159306813 +0000
@@ -1 +1 @@
-from client import *
+from .client import *
--- net-snmp-5.8.old/python/netsnmp/client.py	2018-07-16 07:33:40.000000000 +0000
+++ net-snmp-5.8/python/netsnmp/client.py	2020-05-06 03:57:56.926403347 +0000
@@ -1,3 +1,4 @@
+from __future__ import print_function
 import re
 from sys import stderr
 import netsnmp
@@ -34,12 +35,12 @@
         'TheirHostname':'',
         'TrustCert':''
         }
-    keys = kargs.keys()
+    keys = list(kargs.keys())
     for key in keys:
-        if sessArgs.has_key(key):
+        if key in sessArgs:
             sessArgs[key] = kargs[key]
         else:
-            print >>stderr, "ERROR: unknown key", key
+            print("ERROR: unknown key", key, file=stderr)
     return sessArgs
 
 def STR(obj):
@@ -132,7 +133,7 @@
 
         sess_args = _parse_session_args(args)
 
-        for k, v in sess_args.items():
+        for k, v in list(sess_args.items()):
             self.__dict__[k] = v
 
 

--- net-snmp-5.8.old/python/netsnmp/client_intf.c	2018-07-16 07:33:40.000000000 +0000
+++ net-snmp-5.8/python/netsnmp/client_intf.c	2020-04-22 03:31:50.804615287 +0000
@@ -38,23 +38,12 @@
 
 #define NO_RETRY_NOSUCH 0
 
-#define STRLEN(x) (x ? strlen(x) : 0)
+#define STRLEN(x) (x ? (int)strlen(x) : 0)
 
 
 typedef netsnmp_session SnmpSession;
 typedef struct tree SnmpMibNode;
-static int __is_numeric_oid (char*);
-static int __is_leaf (struct tree*);
-static int __translate_asn_type (int);
-static int __snprint_value (char **, size_t *,
-                            netsnmp_variable_list*, struct tree *,
-                            int, int);
-static int __sprint_num_objid (char **, size_t *, oid *, int);
-static int __scan_num_objid (char *, oid *, size_t *);
-static int __get_type_str (int, char *);
-static int __get_label_iid (char *, char **, char **, int);
-static struct tree * __tag2oid (char *, char *, oid  *, int  *, int *, int);
-static int __concat_oid_str (oid *, int *, char *);
+
 #define USE_NUMERIC_OIDS 0x08
 #define NON_LEAF_NAME 0x04
 #define USE_LONG_NAMES 0x02
@@ -63,45 +52,6 @@
 
 static int _debug_level;
 
-
-void
-__libraries_init(char *appname)
-{
-  static int have_inited = 0;
-
-  if (have_inited)
-    return;
-  have_inited = 1;
-
-  netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
-                         NETSNMP_DS_LIB_QUICK_PRINT, 1);
-  snmp_enable_stderrlog();
-  init_snmp(appname);
-
-  netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS, 1);
-  netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY, 1);
-  netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
-		     NETSNMP_OID_OUTPUT_SUFFIX);
-}
-
-static int
-__is_numeric_oid(char* oidstr)
-{
-  if (!oidstr) return 0;
-  for (; *oidstr; oidstr++) {
-     if (isalpha((int)*oidstr)) return 0;
-  }
-  return(1);
-}
-
-static int
-__is_leaf(struct tree* tp)
-{
-   char buf[MAX_TYPE_NAME_LEN];
-   return (tp && (__get_type_str(tp->type,buf) ||
-		  (tp->parent && __get_type_str(tp->parent->type,buf) )));
-}
-
 struct type_table_entry {
     uint8_t	mib_type;
     uint8_t	asn_type;
@@ -137,6 +87,68 @@
     { }
 };
 
+void
+__libraries_init(const char *appname)
+{
+  static int have_inited = 0;
+
+  if (have_inited)
+    return;
+  have_inited = 1;
+
+  netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
+                         NETSNMP_DS_LIB_QUICK_PRINT, 1);
+  snmp_enable_stderrlog();
+  init_snmp(appname);
+
+  netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
+                         NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS, 1);
+  netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY,
+                     1);
+  netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+		     NETSNMP_OID_OUTPUT_SUFFIX);
+}
+
+static int
+__is_numeric_oid(const char *oidstr)
+{
+  if (!oidstr)
+      return 0;
+  for (; *oidstr; oidstr++) {
+     if (isalpha((unsigned char)*oidstr))
+         return 0;
+  }
+  return 1;
+}
+
+static int
+__get_type_str(int type, char *str)
+{
+    const struct type_table_entry *e;
+
+    for (e = type_table; e->name; e++) {
+        if (type == e->mib_type) {
+            strcpy(str, e->name);
+            return SUCCESS;
+        }
+    }
+
+    strcpy(str, "");
+    if (_debug_level)
+        printf("__get_type_str:FAILURE(%d)\n", type);
+
+    return FAILURE;
+}
+
+static int
+__is_leaf(struct tree* tp)
+{
+   char buf[MAX_TYPE_NAME_LEN];
+
+   return tp && (__get_type_str(tp->type,buf) ||
+                 (tp->parent && __get_type_str(tp->parent->type,buf)));
+}
+
 #ifndef NETSNMP_NO_WRITE_SUPPORT
 static int
 __translate_appl_type(const char *typestr)
@@ -185,19 +197,33 @@
     return *buf;
 }
 
+static int
+__sprint_num_objid(char **buf, size_t *buf_len, const oid *objid, int len)
+{
+   char *p, *end;
+   int i;
+
+   enlarge_buffer(buf, buf_len, len * 16);
+   p = *buf;
+   end = *buf + *buf_len;
+   (*buf)[0] = '\0';
+   for (i = 0; i < len; i++)
+       p += snprintf(p, end - p, ".%lu", *objid++);
+
+   return SUCCESS;
+}
+
 #define USE_BASIC 0
 #define USE_ENUMS 1
 #define USE_SPRINT_VALUE 2
 static int
-__snprint_value(char **buf, size_t *buf_len, netsnmp_variable_list *var,
-                struct tree *tp, int type, int flag)
+__snprint_value(char **buf, size_t *buf_len, const netsnmp_variable_list *var,
+                const struct tree *tp, int type, int flag)
 {
-   size_t out_len = 0;
-   int len = 0;
+   size_t out_len = 0, len = 0;
    u_char* ip;
    struct enum_list *ep;
 
-
    enlarge_buffer(buf, buf_len, 32);
    (*buf)[0] = '\0';
    if (flag == USE_SPRINT_VALUE) {
@@ -228,16 +254,16 @@
         case ASN_COUNTER:
         case ASN_TIMETICKS:
         case ASN_UINTEGER:
-           snprintf(*buf, *buf_len, "%lu", (unsigned long) *var->val.integer);
+           snprintf(*buf, *buf_len, "%lu", *var->val.integer);
            len = STRLEN(*buf);
            break;
 
         case ASN_OCTET_STR:
         case ASN_OPAQUE:
-           len = var->val_len;
+           len = (int)var->val_len;
            enlarge_buffer(buf, buf_len, len + 1);
            if (len > *buf_len - 1)
-               len = *buf_len - 1;
+              len = (int)(*buf_len - 1);
            memcpy(*buf, var->val.string, len);
            break;
 
@@ -251,8 +277,8 @@
            break;
 
         case ASN_OBJECT_ID:
-          __sprint_num_objid(buf, buf_len, (oid *)(var->val.objid),
-                             var->val_len/sizeof(oid));
+          __sprint_num_objid(buf, buf_len, var->val.objid,
+                             (int)var->val_len / sizeof(oid));
           len = STRLEN(*buf);
           break;
 
@@ -271,13 +297,13 @@
         case ASN_OPAQUE_COUNTER64:
         case ASN_OPAQUE_U64:
 #endif
-          printU64(*buf,(struct counter64 *)var->val.counter64);
+          printU64(*buf, var->val.counter64);
           len = STRLEN(*buf);
           break;
 
 #ifdef OPAQUE_SPECIAL_TYPES
         case ASN_OPAQUE_I64:
-          printI64(*buf,(struct counter64 *)var->val.counter64);
+          printI64(*buf, var->val.counter64);
           len = STRLEN(*buf);
           break;
 #endif
@@ -310,27 +336,13 @@
 }
 
 static int
-__sprint_num_objid(char **buf, size_t *buf_len, oid *objid, int len)
+__scan_num_objid(const char *buf, oid *objid, size_t *len)
 {
-   char *p, *end;
-   int i;
-
-   enlarge_buffer(buf, buf_len, len * 16);
-   p = *buf;
-   end = *buf + *buf_len;
-   (*buf)[0] = '\0';
-   for (i = 0; i < len; i++)
-       p += snprintf(p, end - p, ".%lu", *objid++);
+   const char *cp;
 
-   return SUCCESS;
-}
-
-static int
-__scan_num_objid(char *buf, oid *objid, size_t *len)
-{
-   char *cp;
    *len = 0;
-   if (*buf == '.') buf++;
+   if (*buf == '.')
+       buf++;
    cp = buf;
    while (*buf) {
       if (*buf++ == '.') {
@@ -339,7 +351,7 @@
          (*len)++;
          cp = buf;
       } else {
-         if (isalpha((int)*buf)) {
+         if (isalpha((unsigned char)*buf)) {
 	    return FAILURE;
          }
       }
@@ -350,26 +362,7 @@
    return SUCCESS;
 }
 
-static int
-__get_type_str(int type, char * str)
-{
-    const struct type_table_entry *e;
-
-    for (e = type_table; e->name; e++) {
-        if (type == e->mib_type) {
-            strcpy(str, e->name);
-            return SUCCESS;
-        }
-    }
-
-    strcpy(str, "");
-    if (_debug_level)
-        printf("__get_type_str:FAILURE(%d)\n", type);
-
-    return FAILURE;
-}
-
-/* does a destructive disection of <label1>...<labeln>.<iid> returning
+/* does a destructive dissection of <label1>...<labeln>.<iid> returning
    <labeln> and <iid> in seperate strings (note: will destructively
    alter input string, 'name') */
 static int
@@ -382,45 +375,45 @@
 
    *last_label = *iid = NULL;
 
-   if (len == 0) return(FAILURE);
+   if (len == 0)
+       return FAILURE;
 
    /* Handle case where numeric oid's have been requested.  The input 'name'
    ** in this case should be a numeric OID -- return failure if not.
    */
    if ((flag & USE_NUMERIC_OIDS)) {
       if (!__is_numeric_oid(name))
-       return(FAILURE);
+         return FAILURE;
 
       /* Walk backward through the string, looking for first two '.' chars */
       lcp = &(name[len]);
       icp = NULL;
       while (lcp > name) {
-       if (*lcp == '.') {
-
-          /* If this is the first occurence of '.', note it in icp.
-          ** Otherwise, this must be the second occurrence, so break
-          ** out of the loop.
-          */
-          if (icp == NULL)
-             icp = lcp;
-          else
-             break;
-       }
-       lcp --;
+         if (*lcp == '.') {
+            /* If this is the first occurrence of '.', note it in icp.
+            ** Otherwise, this must be the second occurrence, so break
+            ** out of the loop.
+            */
+            if (icp == NULL)
+               icp = lcp;
+            else
+               break;
+         }
+         lcp --;
       }
 
       /* Make sure we found at least a label and index. */
       if (!icp)
-         return(FAILURE);
+         return FAILURE;
 
       /* Push forward past leading '.' chars and separate the strings. */
-      lcp ++;
-      *icp ++ = '\0';
+      lcp++;
+      *icp++ = '\0';
 
-      *last_label = (flag & USE_LONG_NAMES) ? name : lcp;
+      *last_label = flag & USE_LONG_NAMES ? name : lcp;
       *iid        = icp;
 
-      return(SUCCESS);
+      return SUCCESS;
    }
 
    lcp = icp = &(name[len]);
@@ -434,12 +427,14 @@
            icp = lcp;
         }
       }
-      if (!found_label && isalpha((int)*lcp)) found_label = 1;
+      if (!found_label && isalpha((unsigned char)*lcp))
+         found_label = 1;
       lcp--;
    }
 
-   if (!found_label || (!isdigit((int)*(icp+1)) && (flag & FAIL_ON_NULL_IID)))
-      return(FAILURE);
+   if (!found_label || (!isdigit((unsigned char)*(icp+1)) &&
+                        (flag & FAIL_ON_NULL_IID)))
+      return FAILURE;
 
    if (flag & NON_LEAF_NAME) { /* dont know where to start instance id */
      /* put the whole thing in label */
@@ -471,23 +466,58 @@
 
    *iid = icp;
 
-   return(SUCCESS);
+   return SUCCESS;
+}
+
+/* function: __concat_oid_str
+ *
+ * This function converts a dotted-decimal string, soid_str, to an array
+ * of oid types and concatenates them on doid_arr begining at the index
+ * specified by doid_arr_len.
+ *
+ * returns : SUCCESS, FAILURE
+ */
+static int
+__concat_oid_str(oid *doid_arr, size_t *doid_arr_len, const char *soid_str)
+{
+   char *soid_buf;
+   char *cp;
+   char *st;
+
+   if (!soid_str || !*soid_str)
+      return SUCCESS; /* successfully added nothing */
+   if (*soid_str == '.')
+      soid_str++;
+   soid_buf = strdup(soid_str);
+   if (!soid_buf)
+       return FAILURE;
+   cp = strtok_r(soid_buf,".",&st);
+   while (cp) {
+     sscanf(cp, "%lu", &(doid_arr[(*doid_arr_len)++]));
+     /* doid_arr[(*doid_arr_len)++] =  atoi(cp); */
+     cp = strtok_r(NULL,".",&st);
+   }
+   free(soid_buf);
+   return SUCCESS;
 }
 
 /* Convert a tag (string) to an OID array              */
 /* Tag can be either a symbolic name, or an OID string */
 static struct tree *
-__tag2oid(char *tag, char *iid, oid  *oid_arr, int  *oid_arr_len, int *type,
-          int best_guess)
+__tag2oid(const char *tag, const char *iid, oid *oid_arr, size_t *oid_arr_len,
+          int *type, int best_guess)
 {
    struct tree *tp = NULL;
    struct tree *rtp = NULL;
    oid newname[MAX_OID_LEN], *op;
    size_t newname_len = 0;
 
-   if (type) *type = TYPE_UNKNOWN;
-   if (oid_arr_len) *oid_arr_len = 0;
-   if (!tag) goto done;
+   if (type)
+      *type = TYPE_UNKNOWN;
+   if (oid_arr_len)
+      *oid_arr_len = 0;
+   if (!tag)
+      goto done;
 
    /*********************************************************/
    /* best_guess = 0 - same as no switches (read_objid)     */
@@ -522,9 +552,11 @@
      else {
        rtp = tp = get_tree(newname, newname_len, get_tree_head());
      }
-     if (type) *type = (tp ? tp->type : TYPE_UNKNOWN);
-     if ((oid_arr == NULL) || (oid_arr_len == NULL)) return rtp;
-     memcpy(oid_arr,(char*)newname,newname_len*sizeof(oid));
+     if (type)
+        *type = (tp ? tp->type : TYPE_UNKNOWN);
+     if ((oid_arr == NULL) || (oid_arr_len == NULL))
+        return rtp;
+     memcpy(oid_arr, newname, newname_len * sizeof(oid));
      *oid_arr_len = newname_len;
    }
 
@@ -546,9 +578,11 @@
       else {
 	rtp = tp = get_tree(newname, newname_len, get_tree_head());
       }
-      if (type) *type = (tp ? tp->type : TYPE_UNKNOWN);
-      if ((oid_arr == NULL) || (oid_arr_len == NULL)) return rtp;
-      memcpy(oid_arr,(char*)newname,newname_len*sizeof(oid));
+      if (type)
+         *type = (tp ? tp->type : TYPE_UNKNOWN);
+      if ((oid_arr == NULL) || (oid_arr_len == NULL))
+         return rtp;
+      memcpy(oid_arr, newname, newname_len*sizeof(oid));
       *oid_arr_len = newname_len;
    }
 
@@ -557,8 +591,10 @@
    else {
       rtp = tp = find_node(tag, get_tree_head());
       if (tp) {
-         if (type) *type = tp->type;
-         if ((oid_arr == NULL) || (oid_arr_len == NULL)) return rtp;
+         if (type)
+            *type = tp->type;
+         if ((oid_arr == NULL) || (oid_arr_len == NULL))
+            return rtp;
          /* code taken from get_node in snmp_client.c */
          for(op = newname + MAX_OID_LEN - 1; op >= newname; op--){
            *op = tp->subid;
@@ -566,7 +602,7 @@
 	   if (tp == NULL)
 	      break;
          }
-         *oid_arr_len = newname + MAX_OID_LEN - op;
+         *oid_arr_len = (int)(newname + MAX_OID_LEN - op);
          memcpy(oid_arr, op, *oid_arr_len * sizeof(oid));
       } else {
          return(rtp);   /* HACK: otherwise, concat_oid_str confuses things */
@@ -578,43 +614,13 @@
    return(rtp);
 }
 
-/* function: __concat_oid_str
- *
- * This function converts a dotted-decimal string, soid_str, to an array
- * of oid types and concatenates them on doid_arr begining at the index
- * specified by doid_arr_len.
- *
- * returns : SUCCESS, FAILURE
- */
-static int
-__concat_oid_str(oid *doid_arr, int *doid_arr_len, char *soid_str)
-{
-   char *soid_buf;
-   char *cp;
-   char *st;
-
-   if (!soid_str || !*soid_str) return SUCCESS;/* successfully added nothing */
-   if (*soid_str == '.') soid_str++;
-   soid_buf = strdup(soid_str);
-   if (!soid_buf)
-       return FAILURE;
-   cp = strtok_r(soid_buf,".",&st);
-   while (cp) {
-     sscanf(cp, "%lu", &(doid_arr[(*doid_arr_len)++]));
-     /* doid_arr[(*doid_arr_len)++] =  atoi(cp); */
-     cp = strtok_r(NULL,".",&st);
-   }
-   free(soid_buf);
-   return(SUCCESS);
-}
-
 #ifndef NETSNMP_NO_WRITE_SUPPORT
 /*
  * add a varbind to PDU
  */
 static int
-__add_var_val_str(netsnmp_pdu *pdu, oid *name, int name_length, char *val,
-                  int len, int type)
+__add_var_val_str(netsnmp_pdu *pdu, const oid *name, int name_length,
+                  const char *val, int len, int type)
 {
     netsnmp_variable_list *vars;
     oid oidbuf[MAX_OID_LEN];
@@ -739,11 +745,12 @@
 /* takes ss and pdu as input and updates the 'response' argument */
 /* the input 'pdu' argument will be freed */
 static int
-__send_sync_pdu(netsnmp_session *ss, netsnmp_pdu *pdu, netsnmp_pdu **response,
-                int retry_nosuch, char *err_str, int *err_num, int *err_ind)
+__send_sync_pdu(struct session_list *ss, netsnmp_pdu *pdu,
+                netsnmp_pdu **response, int retry_nosuch,
+                char *err_str, int *err_num, int *err_ind)
 {
    int status = 0;
-   long command = pdu->command;
+   int command = pdu->command;
    char *tmp_err_str;
 
    *err_num = 0;
@@ -766,7 +773,8 @@
    status = snmp_sess_synch_response(ss, pdu, response);
    Py_END_ALLOW_THREADS
 
-   if ((*response == NULL) && (status == STAT_SUCCESS)) status = STAT_ERROR;
+   if ((*response == NULL) && (status == STAT_SUCCESS))
+      status = STAT_ERROR;
 
    switch (status) {
       case STAT_SUCCESS:
@@ -776,9 +784,11 @@
 
             case SNMP_ERR_NOSUCHNAME:
                if (retry_nosuch && (pdu = snmp_fix_pdu(*response, command))) {
-                  if (*response) snmp_free_pdu(*response);
+                  if (*response)
+                     snmp_free_pdu(*response);
                   goto retry;
                }
+               /* fall through */
 
             /* Pv1, SNMPsec, Pv2p, v2c, v2u, v2*, and SNMPv3 PDUs */
             case SNMP_ERR_TOOBIG:
@@ -801,11 +811,11 @@
             /* in SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 PDUs */
             case SNMP_ERR_INCONSISTENTNAME:
             default:
-               strlcpy(err_str, (char*)snmp_errstring((*response)->errstat),
-		       STR_BUF_SIZE);
+               strlcpy(err_str, snmp_errstring((int)(*response)->errstat),
+                       STR_BUF_SIZE);
                *err_num = (int)(*response)->errstat;
-	       *err_ind = (*response)->errindex;
-               status = (*response)->errstat;
+               *err_ind = (int)(*response)->errindex;
+               status = (int)(*response)->errstat;
                break;
 	 }
          break;
@@ -818,14 +828,15 @@
 
       default:
          strcat(err_str, "send_sync_pdu: unknown status");
-         *err_num = ss->s_snmp_errno;
+         *err_num = ss->session->s_snmp_errno;
          break;
    }
 done:
    if (tmp_err_str) {
    	free(tmp_err_str);
    }
-   if (_debug_level && *err_num) printf("XXX sync PDU: %s\n", err_str);
+   if (_debug_level && *err_num)
+      printf("XXX sync PDU: %s\n", err_str);
    return(status);
 }
 
@@ -844,16 +855,20 @@
   return PyObject_CallFunction(callable, "");
 }
 
+/*
+ * Retrieve attribute @attr_name of @obj, store it in buffer @val and
+ * store its length in *@len. Terminate @val with '\0' if @len == NULL.
+ */
 static int
-py_netsnmp_attr_string(PyObject *obj, char * attr_name, char **val,
-    Py_ssize_t *len)
+py_netsnmp_attr_string(PyObject *obj, const char *attr_name, char **val,
+                       Py_ssize_t *len)
 {
   *val = NULL;
   if (obj && attr_name && PyObject_HasAttrString(obj, attr_name)) {
     PyObject *attr = PyObject_GetAttrString(obj, attr_name);
     if (attr) {
       int retval;
-      retval = PyString_AsStringAndSize(attr, val, len);
+      retval = PyBytes_AsStringAndSize(attr, val, len);
       Py_DECREF(attr);
       return retval;
     }
@@ -862,15 +877,19 @@
   return -1;
 }
 
-static long long
-py_netsnmp_attr_long(PyObject *obj, char * attr_name)
+/*
+ * Retrieve attribute @attr_name of @obj and return it as a long. Returns -1
+ * on error.
+ */
+static long
+py_netsnmp_attr_long(PyObject *obj, const char *attr_name)
 {
-  long long val = -1;
+  long val = -1;
 
-  if (obj && attr_name  && PyObject_HasAttrString(obj, attr_name)) {
+  if (obj && attr_name && PyObject_HasAttrString(obj, attr_name)) {
     PyObject *attr = PyObject_GetAttrString(obj, attr_name);
     if (attr) {
-      val = PyInt_AsLong(attr);
+      val = PyLong_AsLong(attr);
       Py_DECREF(attr);
     }
   }
@@ -878,12 +897,16 @@
   return val;
 }
 
+/*
+ * Retrieve attribute @attr_name of @obj and return it as a void ponter.
+ * Returns NULL on error.
+ */
 static void *
-py_netsnmp_attr_void_ptr(PyObject *obj, char * attr_name)
+py_netsnmp_attr_void_ptr(PyObject *obj, const char *attr_name)
 {
   void *val = NULL;
 
-  if (obj && attr_name  && PyObject_HasAttrString(obj, attr_name)) {
+  if (obj && attr_name && PyObject_HasAttrString(obj, attr_name)) {
     PyObject *attr = PyObject_GetAttrString(obj, attr_name);
     if (attr) {
       val = PyLong_AsVoidPtr(attr);
@@ -900,18 +923,22 @@
   int verbose = 0;
   PyObject *pkg = PyImport_ImportModule("netsnmp");
   if (pkg) {
-    verbose = py_netsnmp_attr_long(pkg, "verbose");
+    verbose = (int)py_netsnmp_attr_long(pkg, "verbose");
     Py_DECREF(pkg);
   }
 
   return verbose;
 }
 
+/*
+ * Set attribute @attr_name of @obj to the string @val.
+ */
 static int
-py_netsnmp_attr_set_string(PyObject *obj, char *attr_name,
-			   char *val, size_t len)
+py_netsnmp_attr_set_string(PyObject *obj, const char *attr_name,
+			   const char *val, size_t len)
 {
   int ret = -1;
+
   if (obj && attr_name) {
     PyObject* val_obj =  (val ?
 			  Py_BuildValue("s#", val, len) :
@@ -955,13 +982,13 @@
 
     py_netsnmp_attr_set_string(session, "ErrorStr", err_str, STRLEN(err_str));
 
-    tmp_for_conversion = PyInt_FromLong(err_num);
+    tmp_for_conversion = PyLong_FromLong(err_num);
     if (!tmp_for_conversion)
         return; /* nothing better to do? */
     PyObject_SetAttrString(session, "ErrorNum", tmp_for_conversion);
     Py_DECREF(tmp_for_conversion);
 
-    tmp_for_conversion = PyInt_FromLong(err_ind);
+    tmp_for_conversion = PyLong_FromLong(err_ind);
     if (!tmp_for_conversion)
         return; /* nothing better to do? */
     PyObject_SetAttrString(session, "ErrorInd", tmp_for_conversion);
@@ -978,7 +1005,7 @@
   int  retries;
   int  timeout;
   SnmpSession session = {0};
-  SnmpSession *ss = NULL;
+  struct session_list *ss = NULL;
   int verbose = py_netsnmp_verbose();
 
   if (!PyArg_ParseTuple(args, "issiii", &version,
@@ -1025,7 +1052,7 @@
       printf("error:snmp_new_session: Couldn't open SNMP session");
   }
  end:
-  return PyLong_FromVoidPtr((void *)ss);
+  return PyLong_FromVoidPtr(ss);
 }
 
 static PyObject *
@@ -1049,7 +1076,7 @@
   int     eng_boots;
   int     eng_time;
   SnmpSession session = {0};
-  SnmpSession *ss = NULL;
+  struct session_list *ss = NULL;
   int verbose = py_netsnmp_verbose();
 
   if (!PyArg_ParseTuple(args, "isiiisisssssssii", &version,
@@ -1112,7 +1139,7 @@
     if (STRLEN(auth_pass) > 0) {
       session.securityAuthKeyLen = USM_AUTH_KU_LEN;
       if (generate_Ku(session.securityAuthProto,
-		      session.securityAuthProtoLen,
+		      (int)session.securityAuthProtoLen,
 		      (u_char *)auth_pass, STRLEN(auth_pass),
 		      session.securityAuthKey,
 		      &session.securityAuthKeyLen) != SNMPERR_SUCCESS) {
@@ -1143,7 +1170,7 @@
   if (session.securityLevel >= SNMP_SEC_LEVEL_AUTHPRIV) {
     session.securityPrivKeyLen = USM_PRIV_KU_LEN;
     if (generate_Ku(session.securityAuthProto,
-		    session.securityAuthProtoLen,
+		    (int)session.securityAuthProtoLen,
 		    (u_char *)priv_pass, STRLEN(priv_pass),
 		    session.securityPrivKey,
 		    &session.securityPrivKeyLen) != SNMPERR_SUCCESS) {
@@ -1164,7 +1191,7 @@
   free (session.securityEngineID);
   free (session.contextEngineID);
 
-  return PyLong_FromVoidPtr((void *)ss);
+  return PyLong_FromVoidPtr(ss);
 }
 
 static PyObject *
@@ -1184,7 +1211,7 @@
   char *  their_hostname;
   char *  trust_cert;
   SnmpSession session = {0};
-  SnmpSession *ss = NULL;
+  struct session_list *ss;
   int verbose = py_netsnmp_verbose();
 
   if (!PyArg_ParseTuple(args, "isiiisissssss", &version,
@@ -1250,27 +1277,20 @@
                                                        trust_cert));
 
   ss = snmp_sess_open(&session);
-
-  if (!ss)
-      return NULL;
-  /*
-   * Note: on a 64-bit system the statement below discards the upper 32 bits of
-   * "ss", which is most likely a bug.
-   */
-  return Py_BuildValue("i", (int)(uintptr_t)ss);
+  return ss ? PyLong_FromVoidPtr(ss) : NULL;
 }
 
 static PyObject *
 netsnmp_delete_session(PyObject *self, PyObject *args)
 {
   PyObject *session;
-  SnmpSession *ss = NULL;
+  struct session_list *ss;
 
   if (!PyArg_ParseTuple(args, "O", &session)) {
     return NULL;
   }
 
-  ss = (SnmpSession *)py_netsnmp_attr_void_ptr(session, "sess_ptr");
+  ss = py_netsnmp_attr_void_ptr(session, "sess_ptr");
 
   snmp_sess_close(ss);
   return (Py_BuildValue(""));
@@ -1286,13 +1306,13 @@
   PyObject *val_tuple = NULL;
   int varlist_len = 0;
   int varlist_ind;
-  netsnmp_session *ss;
+  struct session_list *ss;
   netsnmp_pdu *pdu, *response;
   netsnmp_variable_list *vars;
   struct tree *tp;
   int len;
   oid *oid_arr;
-  int oid_arr_len = MAX_OID_LEN;
+  size_t oid_arr_len = MAX_OID_LEN;
   int type;
   char type_str[MAX_TYPE_NAME_LEN];
   u_char *str_buf = NULL;
@@ -1321,7 +1341,7 @@
       goto done;
     }
 
-    ss = (SnmpSession *)py_netsnmp_attr_void_ptr(session, "sess_ptr");
+    ss = py_netsnmp_attr_void_ptr(session, "sess_ptr");
 
     if (py_netsnmp_attr_string(session, "ErrorStr", &tmpstr, &tmplen) < 0) {
       goto done;
@@ -1335,8 +1355,8 @@
       sprintval_flag = USE_ENUMS;
     if (py_netsnmp_attr_long(session, "UseSprintValue"))
       sprintval_flag = USE_SPRINT_VALUE;
-    best_guess = py_netsnmp_attr_long(session, "BestGuess");
-    retry_nosuch = py_netsnmp_attr_long(session, "RetryNoSuch");
+    best_guess = (int)py_netsnmp_attr_long(session, "BestGuess");
+    retry_nosuch = (int)py_netsnmp_attr_long(session, "RetryNoSuch");
 
     pdu = snmp_pdu_create(SNMP_MSG_GET);
 
@@ -1440,11 +1460,13 @@
 	if (__is_leaf(tp)) {
 	  type = (tp->type ? tp->type : tp->parent->type);
 	  getlabel_flag &= ~NON_LEAF_NAME;
-	  if (_debug_level) printf("netsnmp_get:is_leaf:%d\n",type);
+	  if (_debug_level)
+             printf("netsnmp_get:is_leaf:%d\n",type);
 	} else {
 	  getlabel_flag |= NON_LEAF_NAME;
 	  type = __translate_asn_type(vars->type);
-	  if (_debug_level) printf("netsnmp_get:!is_leaf:%d\n",tp->type);
+	  if (_debug_level)
+             printf("netsnmp_get:!is_leaf:%d\n",tp->type);
 	}
 	__get_label_iid((char *) str_buf, &tag, &iid, getlabel_flag);
 
@@ -1483,12 +1505,14 @@
 		       NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
 		       old_format);
 
-    if (response) snmp_free_pdu(response);
+    if (response)
+       snmp_free_pdu(response);
   }
 
  done:
   free(oid_arr);
-  if (str_buf != NULL) netsnmp_free(str_buf);
+  if (str_buf != NULL)
+     netsnmp_free(str_buf);
   return (val_tuple ? val_tuple : Py_BuildValue(""));
 }
 
@@ -1501,13 +1525,13 @@
   PyObject *val_tuple = NULL;
   int varlist_len = 0;
   int varlist_ind;
-  netsnmp_session *ss;
+  struct session_list *ss;
   netsnmp_pdu *pdu, *response;
   netsnmp_variable_list *vars;
   struct tree *tp;
   int len;
   oid *oid_arr;
-  int oid_arr_len = MAX_OID_LEN;
+  size_t oid_arr_len = MAX_OID_LEN;
   int type;
   char type_str[MAX_TYPE_NAME_LEN];
   u_char *str_buf = NULL;
@@ -1536,14 +1560,14 @@
       goto done;
     }
 
-    ss = (SnmpSession *)py_netsnmp_attr_void_ptr(session, "sess_ptr");
+    ss = py_netsnmp_attr_void_ptr(session, "sess_ptr");
 
     if (py_netsnmp_attr_string(session, "ErrorStr", &tmpstr, &tmplen) < 0) {
       goto done;
     }
     memcpy(&err_str, tmpstr, tmplen);
-    err_num = py_netsnmp_attr_long(session, "ErrorNum");
-    err_ind = py_netsnmp_attr_long(session, "ErrorInd");
+    err_num = (int)py_netsnmp_attr_long(session, "ErrorNum");
+    err_ind = (int)py_netsnmp_attr_long(session, "ErrorInd");
 
     if (py_netsnmp_attr_long(session, "UseLongNames"))
       getlabel_flag |= USE_LONG_NAMES;
@@ -1553,8 +1577,8 @@
       sprintval_flag = USE_ENUMS;
     if (py_netsnmp_attr_long(session, "UseSprintValue"))
       sprintval_flag = USE_SPRINT_VALUE;
-    best_guess = py_netsnmp_attr_long(session, "BestGuess");
-    retry_nosuch = py_netsnmp_attr_long(session, "RetryNoSuch");
+    best_guess = (int)py_netsnmp_attr_long(session, "BestGuess");
+    retry_nosuch = (int)py_netsnmp_attr_long(session, "RetryNoSuch");
 
     pdu = snmp_pdu_create(SNMP_MSG_GETNEXT);
 
@@ -1571,8 +1595,8 @@
 	}
 
 	if (_debug_level)
-	  printf("netsnmp_getnext: filling request: %s:%s:%d:%d\n",
-		 tag, iid, oid_arr_len,best_guess);
+	  printf("netsnmp_getnext: filling request: %s:%s:%zd:%d\n",
+		 tag, iid, oid_arr_len, best_guess);
 
 	if (oid_arr_len) {
 	  snmp_add_null_var(pdu, oid_arr, oid_arr_len);
@@ -1706,12 +1730,14 @@
 		       NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
 		       old_format);
 
-    if (response) snmp_free_pdu(response);
+    if (response)
+       snmp_free_pdu(response);
   }
 
  done:
   free(oid_arr);
-  if (str_buf != NULL) netsnmp_free(str_buf);
+  if (str_buf != NULL)
+     netsnmp_free(str_buf);
   return (val_tuple ? val_tuple : Py_BuildValue(""));
 }
 
@@ -1726,16 +1752,16 @@
   PyObject *varbinds  = NULL;
   int varlist_len = 0;
   int varlist_ind;
-  netsnmp_session *ss;
+  struct session_list *ss;
   netsnmp_pdu *pdu, *response;
   netsnmp_pdu *newpdu;
   netsnmp_variable_list *vars, *oldvars;
   struct tree *tp;
   int len;
   oid **oid_arr = NULL;
-  int *oid_arr_len = NULL;
+  size_t *oid_arr_len = NULL;
   oid **oid_arr_broken_check = NULL;
-  int *oid_arr_broken_check_len = NULL;
+  size_t *oid_arr_broken_check_len = NULL;
   int type;
   char type_str[MAX_TYPE_NAME_LEN];
   int status;
@@ -1772,14 +1798,14 @@
     if ((varbinds = PyObject_GetAttrString(varlist, "varbinds")) == NULL) {
       goto done;
     }
-    ss = (SnmpSession *)py_netsnmp_attr_void_ptr(session, "sess_ptr");
+    ss = py_netsnmp_attr_void_ptr(session, "sess_ptr");
 
     if (py_netsnmp_attr_string(session, "ErrorStr", &tmpstr, &tmplen) < 0) {
       goto done;
     }
     memcpy(&err_str, tmpstr, tmplen);
-    err_num = py_netsnmp_attr_long(session, "ErrorNum");
-    err_ind = py_netsnmp_attr_long(session, "ErrorInd");
+    err_num = (int)py_netsnmp_attr_long(session, "ErrorNum");
+    err_ind = (int)py_netsnmp_attr_long(session, "ErrorInd");
 
     if (py_netsnmp_attr_long(session, "UseLongNames"))
       getlabel_flag |= USE_LONG_NAMES;
@@ -1789,8 +1815,8 @@
       sprintval_flag = USE_ENUMS;
     if (py_netsnmp_attr_long(session, "UseSprintValue"))
       sprintval_flag = USE_SPRINT_VALUE;
-    best_guess = py_netsnmp_attr_long(session, "BestGuess");
-    retry_nosuch = py_netsnmp_attr_long(session, "RetryNoSuch");
+    best_guess = (int)py_netsnmp_attr_long(session, "BestGuess");
+    retry_nosuch = (int)py_netsnmp_attr_long(session, "RetryNoSuch");
 
     pdu = snmp_pdu_create(SNMP_MSG_GETNEXT);
 
@@ -1802,8 +1828,9 @@
     }
     Py_DECREF(varlist_iter);
 
-    oid_arr_len              = calloc(varlist_len, sizeof(int));
-    oid_arr_broken_check_len = calloc(varlist_len, sizeof(int));
+    oid_arr_len              = calloc(varlist_len, sizeof(*oid_arr_len));
+    oid_arr_broken_check_len = calloc(varlist_len,
+                                      sizeof(*oid_arr_broken_check_len));
 
     oid_arr                  = calloc(varlist_len, sizeof(oid *));
     oid_arr_broken_check     = calloc(varlist_len, sizeof(oid *));
@@ -1833,8 +1860,8 @@
       }
 
       if (_debug_level)
-	printf("netsnmp_walk: filling request: %s:%s:%d:%d\n",
-	       tag, iid, oid_arr_len[varlist_ind],best_guess);
+	printf("netsnmp_walk: filling request: %s:%s:%zd:%d\n",
+	       tag, iid, oid_arr_len[varlist_ind], best_guess);
 
       if (oid_arr_len[varlist_ind]) {
         snmp_add_null_var(pdu, oid_arr[varlist_ind], oid_arr_len[varlist_ind]);
@@ -1921,7 +1948,7 @@
 
         oid_arr_broken_check[varlist_ind] = calloc(MAX_OID_LEN, sizeof(oid));
 
-        oid_arr_broken_check_len[varlist_ind] = vars->name_length;
+        oid_arr_broken_check_len[varlist_ind] = (int)vars->name_length;
         memcpy(oid_arr_broken_check[varlist_ind],
                vars->name, vars->name_length * sizeof(oid));
     }
@@ -2001,7 +2028,8 @@
 
                   __get_label_iid((char *) str_buf, &tag, &iid, getlabel_flag);
 
-                  if (_debug_level) printf("netsnmp_walk: filling response: %s:%s\n", tag, iid);
+                  if (_debug_level)
+                     printf("netsnmp_walk: filling response: %s:%s\n", tag, iid);
 
                   py_netsnmp_attr_set_string(varbind, "tag", tag, STRLEN(tag));
                   py_netsnmp_attr_set_string(varbind, "iid", iid, STRLEN(iid));
@@ -2036,7 +2064,7 @@
 
               memcpy(oid_arr_broken_check[varlist_ind], vars->name,
                      sizeof(oid) * vars->name_length);
-              oid_arr_broken_check_len[varlist_ind] = vars->name_length;
+              oid_arr_broken_check_len[varlist_ind] = (int)vars->name_length;
 
               snmp_add_null_var(newpdu, vars->name,
                                 vars->name_length);
@@ -2071,7 +2099,8 @@
   }
   free(oid_arr);
   free(oid_arr_broken_check);
-  if (str_buf != NULL) netsnmp_free(str_buf);
+  if (str_buf != NULL)
+     netsnmp_free(str_buf);
   return (val_tuple ? val_tuple : Py_BuildValue(""));
 }
 
@@ -2088,13 +2117,13 @@
   PyObject *varbinds_iter;
   PyObject *val_tuple = NULL;
   int varbind_ind;
-  netsnmp_session *ss;
+  struct session_list *ss;
   netsnmp_pdu *pdu, *response;
   netsnmp_variable_list *vars;
   struct tree *tp;
   int len;
   oid *oid_arr;
-  int oid_arr_len = MAX_OID_LEN;
+  size_t oid_arr_len = MAX_OID_LEN;
   int type;
   char type_str[MAX_TYPE_NAME_LEN];
   u_char *str_buf = NULL;
@@ -2126,14 +2155,14 @@
 
     if (varlist && (varbinds = PyObject_GetAttrString(varlist, "varbinds"))) {
 
-      ss = (SnmpSession *)py_netsnmp_attr_void_ptr(session, "sess_ptr");
+      ss = py_netsnmp_attr_void_ptr(session, "sess_ptr");
 
       if (py_netsnmp_attr_string(session, "ErrorStr", &tmpstr, &tmplen) < 0) {
         goto done;
       }
       memcpy(&err_str, tmpstr, tmplen);
-      err_num = py_netsnmp_attr_long(session, "ErrorNum");
-      err_ind = py_netsnmp_attr_long(session, "ErrorInd");
+      err_num = (int)py_netsnmp_attr_long(session, "ErrorNum");
+      err_ind = (int)py_netsnmp_attr_long(session, "ErrorInd");
 
       if (py_netsnmp_attr_long(session, "UseLongNames"))
 	getlabel_flag |= USE_LONG_NAMES;
@@ -2143,8 +2172,8 @@
 	sprintval_flag = USE_ENUMS;
       if (py_netsnmp_attr_long(session, "UseSprintValue"))
 	sprintval_flag = USE_SPRINT_VALUE;
-      best_guess = py_netsnmp_attr_long(session, "BestGuess");
-      retry_nosuch = py_netsnmp_attr_long(session, "RetryNoSuch");
+      best_guess = (int)py_netsnmp_attr_long(session, "BestGuess");
+      retry_nosuch = (int)py_netsnmp_attr_long(session, "RetryNoSuch");
 
       pdu = snmp_pdu_create(SNMP_MSG_GETBULK);
 
@@ -2301,7 +2330,8 @@
 			 NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
 			 old_format);
 
-      if (response) snmp_free_pdu(response);
+      if (response)
+         snmp_free_pdu(response);
 
       Py_DECREF(varbinds);
 
@@ -2319,7 +2349,8 @@
 
  done:
   free(oid_arr);
-  if (str_buf != NULL) netsnmp_free(str_buf);
+  if (str_buf != NULL)
+     netsnmp_free(str_buf);
   return (val_tuple ? val_tuple : Py_BuildValue(""));
 }
 
@@ -2330,8 +2361,8 @@
 #ifndef NETSNMP_NO_WRITE_SUPPORT
   PyObject *session;
   PyObject *varlist;
-  PyObject *varbind;
-  netsnmp_session *ss;
+  PyObject *varbind = NULL;
+  struct session_list *ss;
   netsnmp_pdu *pdu, *response;
   struct tree *tp;
   char *tag;
@@ -2340,7 +2371,7 @@
   char *type_str;
   int len;
   oid *oid_arr;
-  int oid_arr_len = MAX_OID_LEN;
+  size_t oid_arr_len = MAX_OID_LEN;
   int type;
   u_char tmp_val_str[STR_BUF_SIZE];
   int use_enums;
@@ -2362,16 +2393,16 @@
       goto done;
     }
 
-    ss = (SnmpSession *)py_netsnmp_attr_void_ptr(session, "sess_ptr");
+    ss = py_netsnmp_attr_void_ptr(session, "sess_ptr");
 
     /* PyObject_SetAttrString(); */
     if (py_netsnmp_attr_string(session, "ErrorStr", &tmpstr, &tmplen) < 0) {
       goto done;
     }
 
-    use_enums = py_netsnmp_attr_long(session, "UseEnums");
+    use_enums = (int)py_netsnmp_attr_long(session, "UseEnums");
 
-    best_guess = py_netsnmp_attr_long(session, "BestGuess");
+    best_guess = (int)py_netsnmp_attr_long(session, "BestGuess");
 
     pdu = snmp_pdu_create(SNMP_MSG_SET);
 
@@ -2414,7 +2445,7 @@
 	  goto done;
 	}
 	memset(tmp_val_str, 0, sizeof(tmp_val_str));
-        if ( tmplen >= sizeof(tmp_val_str)) {
+        if (tmplen >= (Py_ssize_t)sizeof(tmp_val_str)) {
             tmplen = sizeof(tmp_val_str)-1;
         }
 	memcpy(tmp_val_str, val, tmplen);
@@ -2453,7 +2484,8 @@
 			     err_str, &err_num, &err_ind);
     __py_netsnmp_update_session_errors(session, err_str, err_num, err_ind);
 
-    if (response) snmp_free_pdu(response);
+    if (response)
+       snmp_free_pdu(response);
 
     if (status == STAT_SUCCESS)
       ret = Py_BuildValue("i",1); /* success, return True */
@@ -2490,11 +2522,26 @@
   {NULL, NULL, 0, NULL}        /* Sentinel */
 };
 
+#if PY_VERSION_HEX < 0x03000000
 PyMODINIT_FUNC
 initclient_intf(void)
 {
     (void) Py_InitModule("client_intf", ClientMethods);
 }
+#else
+static PyModuleDef module_def = {
+    .m_base = PyModuleDef_HEAD_INIT,
+    .m_name = "client_intf",
+    .m_size = -1,
+    .m_methods = ClientMethods,
+};
+
+PyMODINIT_FUNC
+PyInit_client_intf(void)
+{
+    return PyModule_Create(&module_def);
+}
+#endif
 
 
 

--- net-snmp-5.8.old/python/netsnmp/netsnmp-feature-definitions.h	2018-07-16 07:33:40.000000000 +0000
+++ net-snmp-5.8/python/netsnmp/netsnmp-feature-definitions.h	2020-05-06 03:57:56.897024596 +0000
@@ -1,7 +1,7 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-netsnmp_feature_require(enable_stderrlog)
-netsnmp_feature_require(memory_malloc)
-netsnmp_feature_require(memory_free)
+netsnmp_feature_require(enable_stderrlog);
+netsnmp_feature_require(memory_malloc);
+netsnmp_feature_require(memory_free);
 
--- net-snmp-5.8.old/python/netsnmp/tests/test.py	2018-07-16 07:33:40.000000000 +0000
+++ net-snmp-5.8/python/netsnmp/tests/test.py	2020-05-06 03:57:56.918554087 +0000
@@ -12,7 +12,7 @@
         'DestHost':   'localhost:' + os.environ.get("SNMP_SNMPD_PORT", 161),
         'Community':  'public',
     }
-    for key, value in kwargs.iteritems():
+    for key, value in kwargs.items():
         dest[key] = value
     return dest
 
@@ -62,107 +62,107 @@
         self.assertEqual(var.iid, '')
 
     def test_v1_get(self):
-        print "\n"
-        print "---v1 GET tests -------------------------------------\n"
+        print("\n")
+        print("---v1 GET tests -------------------------------------\n")
         var = netsnmp.Varbind('.1.3.6.1.2.1.1.1', '0')
         res = netsnmp.snmpget(var, **snmp_dest())
 
-        print "v1 snmpget result: ", res, "\n"
+        print("v1 snmpget result: ", res, "\n")
         self.assertEqual(len(res), 1)
 
-        print "v1 get var: ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+        print("v1 get var: ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
         self.assertEqual(var.tag, 'sysDescr')
         self.assertEqual(var.iid, '0')
         self.assertEqual(var.val, res[0])
         self.assertEqual(var.type, 'OCTETSTR')
 
     def test_v1_getnext(self):
-        print "\n"
-        print "---v1 GETNEXT tests-------------------------------------\n"
+        print("\n")
+        print("---v1 GETNEXT tests-------------------------------------\n")
         var = netsnmp.Varbind('.1.3.6.1.2.1.1.1', '0')
         res = netsnmp.snmpgetnext(var, **snmp_dest())
 
-        print "v1 snmpgetnext result: ", res, "\n"
+        print("v1 snmpgetnext result: ", res, "\n")
         self.assertEqual(len(res), 1)
 
-        print "v1 getnext var: ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+        print("v1 getnext var: ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
         self.assertTrue(var.tag is not None)
         self.assertTrue(var.iid is not None)
         self.assertTrue(var.val is not None)
         self.assertTrue(var.type is not None)
 
     def test_v1_set(self):
-        print "\n"
-        print "---v1 SET tests-------------------------------------\n"
+        print("\n")
+        print("---v1 SET tests-------------------------------------\n")
         var = netsnmp.Varbind('sysLocation', '0', 'my new location')
         res = netsnmp.snmpset(var, **snmp_dest())
 
-        print "v1 snmpset result: ", res, "\n"
+        print("v1 snmpset result: ", res, "\n")
         self.assertEqual(res, 1)
 
-        print "v1 set var: ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+        print("v1 set var: ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
         self.assertEqual(var.tag, 'sysLocation')
         self.assertEqual(var.iid, '0')
         self.assertEqual(var.val, 'my new location')
         self.assertTrue(var.type is None)
 
     def test_v1_walk(self):
-        print "\n"
-        print "---v1 walk tests-------------------------------------\n"
+        print("\n")
+        print("---v1 walk tests-------------------------------------\n")
         varlist = netsnmp.VarList(netsnmp.Varbind('system'))
 
-        print "v1 varlist walk in: "
+        print("v1 varlist walk in: ")
         for var in varlist:
-            print "  ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print("  ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
         res = netsnmp.snmpwalk(varlist, **snmp_dest())
-        print "v1 snmpwalk result: ", res, "\n"
+        print("v1 snmpwalk result: ", res, "\n")
         self.assertTrue(len(res) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
     def test_v1_walk_2(self):
-        print "\n"
-        print "---v1 walk 2-------------------------------------\n"
+        print("\n")
+        print("---v1 walk 2-------------------------------------\n")
 
-        print "v1 varbind walk in: "
+        print("v1 varbind walk in: ")
         var = netsnmp.Varbind('system')
         self.assertEqual(var.tag, 'system')
         self.assertEqual(var.iid, '')
         self.assertEqual(var.val, None)
         self.assertEqual(var.type, None)
         res = netsnmp.snmpwalk(var, **snmp_dest())
-        print "v1 snmpwalk result (should be = orig): ", res, "\n"
+        print("v1 snmpwalk result (should be = orig): ", res, "\n")
         self.assertTrue(len(res) > 0)
 
-        print var.tag, var.iid, "=", var.val, '(', var.type, ')'
+        print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
         self.assertEqual(var.tag, 'system')
         self.assertEqual(var.iid, '')
         self.assertEqual(var.val, None)
         self.assertEqual(var.type, None)
 
     def test_v1_mv_get(self):
-        print "\n"
-        print "---v1 multi-varbind test-------------------------------------\n"
+        print("\n")
+        print("---v1 multi-varbind test-------------------------------------\n")
         sess = setup_v1()
 
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime', 0),
                                   netsnmp.Varbind('sysContact', 0),
                                   netsnmp.Varbind('sysLocation', 0))
         vals = sess.get(varlist)
-        print "v1 sess.get result: ", vals, "\n"
+        print("v1 sess.get result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
         vals = sess.getnext(varlist)
-        print "v1 sess.getnext result: ", vals, "\n"
+        print("v1 sess.getnext result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime'),
                                   netsnmp.Varbind('sysORLastChange'),
@@ -171,71 +171,71 @@
                                   netsnmp.Varbind('sysORUpTime'))
 
         vals = sess.getbulk(2, 8, varlist)
-        print "v1 sess.getbulk result: ", vals, "\n"
+        print("v1 sess.getbulk result: ", vals, "\n")
         self.assertEqual(vals, None) # GetBulk is not supported for v1
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
     def test_v1_set_2(self):
-        print "\n"
-        print "---v1 set2-------------------------------------\n"
+        print("\n")
+        print("---v1 set2-------------------------------------\n")
 
         sess = setup_v1()
         varlist = netsnmp.VarList(
             netsnmp.Varbind('sysLocation', '0', 'my newer location'))
         res = sess.set(varlist)
-        print "v1 sess.set result: ", res, "\n"
+        print("v1 sess.set result: ", res, "\n")
 
     def test_v1_walk_3(self):
-        print "\n"
-        print "---v1 walk3-------------------------------------\n"
+        print("\n")
+        print("---v1 walk3-------------------------------------\n")
 
         sess = setup_v1()
         varlist = netsnmp.VarList(netsnmp.Varbind('system'))
 
         vals = sess.walk(varlist)
-        print "v1 sess.walk result: ", vals, "\n"
+        print("v1 sess.walk result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print "  ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print("  ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
     def test_v2c_get(self):
-        print "\n"
-        print "---v2c get-------------------------------------\n"
+        print("\n")
+        print("---v2c get-------------------------------------\n")
 
         sess = setup_v2()
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime', 0),
                                   netsnmp.Varbind('sysContact', 0),
                                   netsnmp.Varbind('sysLocation', 0))
         vals = sess.get(varlist)
-        print "v2 sess.get result: ", vals, "\n"
+        print("v2 sess.get result: ", vals, "\n")
         self.assertEqual(len(vals), 3)
 
     def test_v2c_getnext(self):
-        print "\n"
-        print "---v2c getnext-------------------------------------\n"
+        print("\n")
+        print("---v2c getnext-------------------------------------\n")
 
         sess = setup_v2()
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime', 0),
                                   netsnmp.Varbind('sysContact', 0),
                                   netsnmp.Varbind('sysLocation', 0))
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
         vals = sess.getnext(varlist)
-        print "v2 sess.getnext result: ", vals, "\n"
+        print("v2 sess.getnext result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
     def test_v2c_getbulk(self):
-        print "\n"
-        print "---v2c getbulk-------------------------------------\n"
+        print("\n")
+        print("---v2c getbulk-------------------------------------\n")
 
         sess = setup_v2()
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime'),
@@ -245,16 +245,16 @@
                                   netsnmp.Varbind('sysORUpTime'))
 
         vals = sess.getbulk(2, 8, varlist)
-        print "v2 sess.getbulk result: ", vals, "\n"
+        print("v2 sess.getbulk result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
     def test_v2c_set(self):
-        print "\n"
-        print "---v2c set-------------------------------------\n"
+        print("\n")
+        print("---v2c set-------------------------------------\n")
 
         sess = setup_v2()
 
@@ -262,54 +262,54 @@
             netsnmp.Varbind('sysLocation', '0', 'my even newer location'))
 
         res = sess.set(varlist)
-        print "v2 sess.set result: ", res, "\n"
+        print("v2 sess.set result: ", res, "\n")
         self.assertEqual(res, 1)
 
     def test_v2c_walk(self):
-        print "\n"
-        print "---v2c walk-------------------------------------\n"
+        print("\n")
+        print("---v2c walk-------------------------------------\n")
 
         sess = setup_v2()
 
         varlist = netsnmp.VarList(netsnmp.Varbind('system'))
 
         vals = sess.walk(varlist)
-        print "v2 sess.walk result: ", vals, "\n"
+        print("v2 sess.walk result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print "  ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print("  ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
     def test_v3_get(self):
-        print "\n"
+        print("\n")
         sess = setup_v3();
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime', 0),
                                   netsnmp.Varbind('sysContact', 0),
                                   netsnmp.Varbind('sysLocation', 0))
-        print "---v3 get-------------------------------------\n"
+        print("---v3 get-------------------------------------\n")
         vals = sess.get(varlist)
-        print "v3 sess.get result: ", vals, "\n"
+        print("v3 sess.get result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
     def test_v3_getnext(self):
-        print "\n"
-        print "---v3 getnext-------------------------------------\n"
+        print("\n")
+        print("---v3 getnext-------------------------------------\n")
 
         sess = setup_v3();
         varlist = netsnmp.VarList(netsnmp.Varbind('sysUpTime', 0),
                                   netsnmp.Varbind('sysContact', 0),
                                   netsnmp.Varbind('sysLocation', 0))
         vals = sess.getnext(varlist)
-        print "v3 sess.getnext result: ", vals, "\n"
+        print("v3 sess.getnext result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
     def test_v3_getbulk(self):
         sess = setup_v3();
@@ -320,47 +320,47 @@
                                   netsnmp.Varbind('sysORUpTime'))
 
         vals = sess.getbulk(2, 8, varlist)
-        print "v3 sess.getbulk result: ", vals, "\n"
+        print("v3 sess.getbulk result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
     def test_v3_set(self):
-        print "\n"
-        print "---v3 set-------------------------------------\n"
+        print("\n")
+        print("---v3 set-------------------------------------\n")
 
         sess = setup_v3();
         varlist = netsnmp.VarList(
             netsnmp.Varbind('sysLocation', '0', 'my final destination'))
         res = sess.set(varlist)
-        print "v3 sess.set result: ", res, "\n"
+        print("v3 sess.set result: ", res, "\n")
         self.assertEqual(res, 1)
 
     def test_v3_walk(self):
-        print "\n"
-        print "---v3 walk-------------------------------------\n"
+        print("\n")
+        print("---v3 walk-------------------------------------\n")
         sess = setup_v3();
         varlist = netsnmp.VarList(netsnmp.Varbind('system'))
 
         vals = sess.walk(varlist)
-        print "v3 sess.walk result: ", vals, "\n"
+        print("v3 sess.walk result: ", vals, "\n")
         self.assertTrue(len(vals) > 0)
 
         for var in varlist:
-            print "  ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+            print("  ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
 
 
 class SetTests(unittest.TestCase):
     """SNMP set tests for the Net-SNMP Python interface"""
     def testFuncs(self):
         """Test code"""
-        print "\n-------------- SET Test Start ----------------------------\n"
+        print("\n-------------- SET Test Start ----------------------------\n")
 
         var = netsnmp.Varbind('sysUpTime', '0')
         res = netsnmp.snmpget(var, **snmp_dest())
-        print "uptime = ", res[0]
+        print("uptime = ", res[0])
         self.assertEqual(len(res), 1)
 
 
@@ -370,19 +370,19 @@
 
         var = netsnmp.Varbind('sysUpTime', '0')
         res = netsnmp.snmpget(var, **snmp_dest())
-        print "uptime = ", res[0]
+        print("uptime = ", res[0])
         self.assertEqual(len(res), 1)
 
         var = netsnmp.Varbind('nsCacheEntry')
         res = netsnmp.snmpgetnext(var, **snmp_dest())
-        print "var = ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+        print("var = ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
         self.assertEqual(len(res), 1)
 
         var.val = 65
         res = netsnmp.snmpset(var, **snmp_dest())
         self.assertEqual(res, 1)
         res = netsnmp.snmpget(var, **snmp_dest())
-        print "var = ", var.tag, var.iid, "=", var.val, '(', var.type, ')'
+        print("var = ", var.tag, var.iid, "=", var.val, '(', var.type, ')')
         self.assertEqual(len(res), 1)
         self.assertEqual(res[0], '65');
 
@@ -394,7 +394,7 @@
             netsnmp.Varbind('.1.3.6.1.6.3.12.1.2.1.9.116.101.115.116', '', 4))
         res = sess.set(varlist)
 
-        print "res = ", res
+        print("res = ", res)
         self.assertEqual(res, 1)
 
         varlist = netsnmp.VarList(netsnmp.Varbind('snmpTargetAddrTDomain'),
@@ -414,15 +414,15 @@
         self.assertEqual(varlist[2].val, '3')
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
         varlist = netsnmp.VarList(
             netsnmp.Varbind('.1.3.6.1.6.3.12.1.2.1.9.116.101.115.116', '', 6))
 
         res = sess.set(varlist)
 
-        print "res = ", res
+        print("res = ", res)
         self.assertEqual(res, 1)
 
         varlist = netsnmp.VarList(netsnmp.Varbind('snmpTargetAddrTDomain'),
@@ -436,10 +436,10 @@
         self.assertNotEqual(varlist[2].tag, 'snmpTargetAddrRowStatus')
 
         for var in varlist:
-            print var.tag, var.iid, "=", var.val, '(', var.type, ')'
-        print "\n"
+            print(var.tag, var.iid, "=", var.val, '(', var.type, ')')
+        print("\n")
 
-        print "\n-------------- SET Test End ----------------------------\n"
+        print("\n-------------- SET Test End ----------------------------\n")
 
 
 if __name__ == '__main__':
--- net-snmp-5.8.old/python/setup.py	2018-07-16 07:33:40.000000000 +0000
+++ net-snmp-5.8/python/setup.py	2020-05-06 03:57:56.926697675 +0000
@@ -2,16 +2,15 @@
 from setuptools import setup, Extension, find_packages
 import os
 import re
-import string
 import sys
 
 intree=0
 
 args = sys.argv[:]
 for arg in args:
-    if string.find(arg,'--basedir=') == 0:
-        basedir = string.split(arg,'=')[1]
-	sys.argv.remove(arg)
+    if arg.find('--basedir=') == 0:
+        basedir = arg.split('=')[1]
+        sys.argv.remove(arg)
         intree=1
 
 if intree:
