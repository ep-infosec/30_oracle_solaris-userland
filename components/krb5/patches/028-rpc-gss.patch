#
# Make MIT Kerberos use Solaris RPC and RPCSEC_GSS instead of libgssrpc.
#
# MIT Kerberos bundles the RPC and RPCSEC_GSS implementation with the
# source in separate libgssrpc library. The RPC implementation is based on
# an ancient SUN donated code. It is inferior to the RPC implementation in
# Solaris libc in features and possibly in performance too. Also introducing
# a duplicate implementation would not be wise.
#
# In Solaris, IPv6 is supported only in TI-RPC, older TS-RPC is IPv4 only.
# MIT has patched their TS-RPC for limited IPv6 support.
#
# The patch modifies MIT code to use the standard RPC and RPCSEC_GSS in Solaris.
#
# Specifically:
#    - it modifies the Makefiles not to build libgssrpc and not to link with it
#    - related to above, it strips libgssrpc from krb5-config
#    - moves xdr_alloc.c out of libgssrpc and fixes it for 64-bit
#    - includes correct headers - rpc/rpc.h instead of gssrpc/rpc.h
#    - modifies net-server code to support TI-RPC (transport independent, XTI)
#    - implement kadmin protocol and incr. prop. using Solaris RPCSEC_GSS
#    - reverts MIT modification to iprop, that were needed for RPC differences
#    - makes iprop_port optional again (MIT made it mandatory)
#    - hierarchical incremental propagation tests are removed from t_iprop.py,
#      because the Solaris RPC implementation precludes running this scenario on
#      a single host
#    - server side support for RPCSEC_GSS base changepw protocol
#    - recognize sunw_dbprop_* config options for backward compatibility
#    - defines several functions to locate servers (admin, cpw, kiprop,...)
#    - updates generated dependencies for kadm_host_srv_names.so to build
#    - defines xdr_u_int32 and xdr_int32
#
# This patch is Solaris specific and is not intended for upstream contribution.
# In the future MIT might provide support for system native RPC implementation.
# Patch source: in-house
#
--- a/src/build-tools/krb5-config.in
+++ b/src/build-tools/krb5-config.in
@@ -96,9 +96,6 @@ while test $# != 0; do
 	gssapi)
 	    library=gssapi
 	    ;;
-	gssrpc)
-	    library=gssrpc
-	    ;;
 	kadm-client)
 	    library=kadm_client
 	    ;;
@@ -141,7 +138,6 @@ if test -n "$do_help"; then
     echo "Libraries:"
     echo "        krb5              Kerberos 5 application"
     echo "        gssapi            GSSAPI application with Kerberos 5 bindings"
-    echo "        gssrpc            GSSAPI RPC application"
     echo "        kadm-client       Kadmin client"
     echo "        kadm-server       Kadmin server"
     echo "        kdb               Application that accesses the kerberos database"
@@ -231,17 +227,10 @@ if test -n "$do_libs"; then
 
     if test $library = 'kadm_server'; then
 	lib_flags="$lib_flags -lkadm5srv_mit -lkdb5 $KDB5_DB_LIB"
-	library=gssrpc
     fi
 
     if test $library = 'kadm_client'; then
 	lib_flags="$lib_flags -lkadm5clnt_mit"
-	library=gssrpc
-    fi
-
-    if test $library = 'gssrpc'; then
-	lib_flags="$lib_flags -lgssrpc"
-	library=gssapi
     fi
 
     if test $library = 'gssapi'; then
--- a/src/config/pre.in
+++ b/src/config/pre.in
@@ -300,7 +300,7 @@ KDB5_PLUGIN_LIBS = @KDB5_PLUGIN_LIBS@
 KADMCLNT_DEPLIB	= $(TOPLIBD)/libkadm5clnt_mit$(DEPLIBEXT)
 KADMSRV_DEPLIB	= $(TOPLIBD)/libkadm5srv_mit$(DEPLIBEXT)
 KDB5_DEPLIB	= $(TOPLIBD)/libkdb5$(DEPLIBEXT)
-GSSRPC_DEPLIB	= $(TOPLIBD)/libgssrpc$(DEPLIBEXT)
+GSSRPC_DEPLIB	= # empty
 GSS_DEPLIB	= $(TOPLIBD)/libgssapi_krb5$(DEPLIBEXT)
 KRB5_DEPLIB	= $(TOPLIBD)/libkrb5$(DEPLIBEXT)
 CRYPTO_DEPLIB	= $(TOPLIBD)/libk5crypto$(DEPLIBEXT)
@@ -383,7 +383,7 @@ KRB5_BASE_LIBS	= $(KRB5_LIB) $(K5CRYPTO_LIB) $(COM_ERR_LIB) $(SUPPORT_LIB) $(GEN
 KDB5_LIBS	= $(KDB5_LIB) $(GSSRPC_LIBS)
 GSS_LIBS	= $(GSS_KRB5_LIB)
 # needs fixing if ever used on macOS!
-GSSRPC_LIBS	= -lgssrpc $(GSS_LIBS)
+GSSRPC_LIBS	=  $(GSS_LIBS)
 KADM_COMM_LIBS	= $(GSSRPC_LIBS)
 # need fixing if ever used on macOS!
 KADMSRV_LIBS	= -lkadm5srv_mit $(HESIOD_LIBS) $(KDB5_LIBS) $(KADM_COMM_LIBS)
--- a/src/include/iprop.h
+++ b/src/include/iprop.h
@@ -6,8 +6,7 @@
 #ifndef _IPROP_H_RPCGEN
 #define _IPROP_H_RPCGEN
 
-#include <gssrpc/rpc.h>
-
+#include <rpc/rpc.h>
 
 #ifdef __cplusplus
 extern "C" {
--- a/src/include/k5-int.h
+++ b/src/include/k5-int.h
@@ -222,9 +222,12 @@ typedef unsigned char   u_char;
 #define KRB5_CONF_HTTP_ANCHORS                 "http_anchors"
 #define KRB5_CONF_IGNORE_ACCEPTOR_HOSTNAME     "ignore_acceptor_hostname"
 #define KRB5_CONF_IPROP_ENABLE                 "iprop_enable"
+#define KRB5_CONF_SUNW_DBPROP_ENABLE           "sunw_dbprop_enable"
 #define KRB5_CONF_IPROP_LISTEN                 "iprop_listen"
 #define KRB5_CONF_IPROP_LOGFILE                "iprop_logfile"
 #define KRB5_CONF_IPROP_MASTER_ULOGSIZE        "iprop_master_ulogsize"
+#define KRB5_CONF_SUNW_DBPROP_MASTER_ULOGSIZE  "sunw_dbprop_master_ulogsize"
+#define KRB5_CONF_SUNW_DBPROP_SLAVE_POLL       "sunw_dbprop_slave_poll"
 #define KRB5_CONF_IPROP_PORT                   "iprop_port"
 #define KRB5_CONF_IPROP_RESYNC_TIMEOUT         "iprop_resync_timeout"
 #define KRB5_CONF_IPROP_REPLICA_POLL           "iprop_replica_poll"
--- a/src/kadmin/dbutil/kadm5_create.c
+++ b/src/kadmin/dbutil/kadm5_create.c
@@ -139,18 +139,76 @@ int kadm5_create_magic_princs(kadm5_config_params *params,
 static int add_admin_princs(void *handle, krb5_context context, char *realm)
 {
     krb5_error_code ret = 0;
+    char *service_name = 0, *kiprop_name = 0, *canonhost = 0, *chpw_name = NULL;
+    char localname[MAXHOSTNAMELEN];
 
+    if (gethostname(localname, MAXHOSTNAMELEN)) {
+        ret = errno;
+        perror("gethostname");
+        goto clean_and_exit;
+    }
+    ret = krb5_expand_hostname(context, localname, &canonhost);
+    if (ret) {
+        com_err(progname, ret, _("while canonicalizing local hostname"));
+        goto clean_and_exit;
+    }
+    if (asprintf(&service_name, "kadmin/%s", canonhost) < 0) {
+        ret = ENOMEM;
+        fprintf(stderr, _("Out of memory\n"));
+        goto clean_and_exit;
+    }
+    if (asprintf(&chpw_name, "changepw/%s", canonhost) < 0) {
+        ret = ENOMEM;
+        fprintf(stderr, _("Out of memory\n"));
+        goto clean_and_exit;
+    }
+    if (asprintf(&kiprop_name, "kiprop/%s", canonhost) < 0) {
+        ret = ENOMEM;
+        fprintf(stderr, _("Out of memory\n"));
+        goto clean_and_exit;
+    }
+
+    if ((ret = add_admin_princ(handle, context,
+                               service_name, realm,
+                               KRB5_KDB_DISALLOW_TGT_BASED |
+                               KRB5_KDB_LOCKDOWN_KEYS,
+                               ADMIN_LIFETIME)))
+        goto clean_and_exit;
+
+    if ((ret = add_admin_princ(handle, context,
+                               chpw_name, realm,
+                               KRB5_KDB_DISALLOW_TGT_BASED |
+                               KRB5_KDB_PWCHANGE_SERVICE,
+                               ADMIN_LIFETIME)))
+        goto clean_and_exit;
+
+/* kadmin/admin unusable with Solaris rpcsec_gss */
+#if 0
     if ((ret = add_admin_princ(handle, context,
                                KADM5_ADMIN_SERVICE, realm,
                                KRB5_KDB_DISALLOW_TGT_BASED |
                                KRB5_KDB_LOCKDOWN_KEYS,
                                ADMIN_LIFETIME)))
-        return ret;
+        goto clean_and_exit;
+#endif
 
-    return add_admin_princ(handle, context, KADM5_CHANGEPW_SERVICE, realm,
-                           KRB5_KDB_DISALLOW_TGT_BASED |
-                           KRB5_KDB_PWCHANGE_SERVICE | KRB5_KDB_LOCKDOWN_KEYS,
-                           CHANGEPW_LIFETIME);
+    if ((ret = add_admin_princ(handle, context,
+                               KADM5_CHANGEPW_SERVICE, realm,
+                               KRB5_KDB_DISALLOW_TGT_BASED |
+                               KRB5_KDB_PWCHANGE_SERVICE |
+                               KRB5_KDB_LOCKDOWN_KEYS,
+                               CHANGEPW_LIFETIME)))
+        goto clean_and_exit;
+
+    ret = add_admin_princ(handle, context, kiprop_name, realm, 0, 0);
+
+clean_and_exit:
+    krb5_free_string(context, canonhost);
+    free(service_name);
+    free(kiprop_name);
+    free(chpw_name);
+
+    return ret;
 }
 
 /*
--- a/src/kadmin/server/ipropd_svc.c
+++ b/src/kadmin/server/ipropd_svc.c
@@ -152,6 +152,8 @@ iprop_get_updates_1_svc(kdb_last_t *arg, struct svc_req *rqstp)
     kadm5_server_handle_t handle = global_server_handle;
     char *client_name = 0, *service_name = 0;
     char obuf[256] = {0};
+    gss_name_t name = NULL;
+    OM_uint32 min_stat;
 
     /* default return code */
     ret.ret = UPDATE_ERROR;
@@ -188,6 +190,13 @@ iprop_get_updates_1_svc(kdb_last_t *arg, struct svc_req *rqstp)
     DPRINT("%s: clprinc=`%s'\n\tsvcprinc=`%s'\n", whoami, client_name,
 	   service_name);
 
+    if (!(name = rqst2name(rqstp))) {
+        krb5_klog_syslog(LOG_ERR,
+                         _("%s: Couldn't obtain client's name"),
+                         whoami);
+        goto out;
+    }
+
     if (!iprop_acl_check(handle->context, client_name)) {
 	ret.ret = UPDATE_PERM_DENIED;
 
@@ -233,6 +242,8 @@ out:
 	debprret(whoami, ret.ret, ret.lastentry.last_sno);
     free(client_name);
     free(service_name);
+    if (name)
+        gss_release_name(&min_stat, &name);
     return (&ret);
 }
 
@@ -263,6 +274,20 @@ ipropx_resync(uint32_t vers, struct svc_req *rqstp)
     int pret, fret;
     FILE *p;
     kadm5_server_handle_t handle = global_server_handle;
+    /*
+     * The following two definitions are dead code in upstream krb5.
+     *
+     * OM_uint32 min_stat;
+     * gss_name_t name = NULL;
+     *
+     * They come from initial Sun donation of iprop.
+     * For Solaris specific RPC implementation we need them back.
+     * If upstream removes the dead code, hopefuly placing this comment
+     * in this place will result in an easy-to-debug patch error,
+     * rather then failure to compile.
+     */
+    OM_uint32 min_stat;
+    gss_name_t name = NULL;
     char *client_name = NULL, *service_name = NULL;
     char *whoami = "iprop_full_resync_1";
 
@@ -309,6 +334,13 @@ ipropx_resync(uint32_t vers, struct svc_req *rqstp)
     DPRINT("%s: clprinc=`%s'\n\tsvcprinc=`%s'\n",
 	    whoami, client_name, service_name);
 
+    if (!(name = rqst2name(rqstp))) {
+        krb5_klog_syslog(LOG_ERR,
+                         _("%s: Couldn't obtain client's name"),
+                         whoami);
+        goto out;
+    }
+
     if (!iprop_acl_check(handle->context, client_name)) {
 	ret.ret = UPDATE_PERM_DENIED;
 
@@ -438,6 +470,8 @@ out:
 	debprret(whoami, ret.ret, 0);
     free(client_name);
     free(service_name);
+    if (name)
+	gss_release_name(&min_stat, &name);
     free(ubuf);
     return (&ret);
 }
@@ -454,6 +488,7 @@ iprop_full_resync_ext_1_svc(uint32_t *argp, struct svc_req *rqstp)
     return ipropx_resync(*argp, rqstp);
 }
 
+#if 0
 static int
 check_iprop_rpcsec_auth(struct svc_req *rqstp)
 {
@@ -526,6 +561,7 @@ fail_name:
      gss_release_name(&min_stat, &name);
      return success;
 }
+#endif
 
 void
 krb5_iprop_prog_1(struct svc_req *rqstp,
@@ -539,6 +575,7 @@ krb5_iprop_prog_1(struct svc_req *rqstp,
     void *(*local)(/* union XXX *, struct svc_req * */);
     char *whoami = "krb5_iprop_prog_1";
 
+#if 0
     if (!check_iprop_rpcsec_auth(rqstp)) {
 	krb5_klog_syslog(LOG_ERR, _("authentication attempt failed: %s, RPC "
 				    "authentication flavor %d"),
@@ -547,6 +584,7 @@ krb5_iprop_prog_1(struct svc_req *rqstp,
 	svcerr_weakauth(transp);
 	return;
     }
+#endif
 
     switch (rqstp->rq_proc) {
     case NULLPROC:
--- a/src/kadmin/server/kadm_rpc_svc.c
+++ b/src/kadmin/server/kadm_rpc_svc.c
@@ -5,7 +5,7 @@
  */
 
 #include <k5-int.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */
 #include <syslog.h>
 #include <kadm5/kadm_rpc.h>
@@ -76,8 +76,7 @@ void kadm_1(rqstp, transp)
      bool_t (*xdr_argument)(), (*xdr_result)();
      bool_t (*local)();
 
-     if (rqstp->rq_cred.oa_flavor != AUTH_GSSAPI &&
-	 !check_rpcsec_auth(rqstp)) {
+     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS) {
 	  krb5_klog_syslog(LOG_ERR, "Authentication attempt failed: %s, "
 			   "RPC authentication flavor %d",
 			   client_addr(rqstp->rq_xprt),
@@ -248,7 +247,7 @@ void kadm_1(rqstp, transp)
 	  return;
      }
      memset(&argument, 0, sizeof(argument));
-     if (!svc_getargs(transp, xdr_argument, &argument)) {
+     if (!svc_getargs(transp, xdr_argument, (char *)&argument)) {
 	  svcerr_decode(transp);
 	  return;
      }
@@ -259,17 +258,19 @@ void kadm_1(rqstp, transp)
 		 "continuing.");
 	  svcerr_systemerr(transp);
      }
-     if (!svc_freeargs(transp, xdr_argument, &argument)) {
+     if (!svc_freeargs(transp, xdr_argument, (char *)&argument)) {
 	  krb5_klog_syslog(LOG_ERR, "WARNING! Unable to free arguments, "
 		 "continuing.");
      }
-     if (!svc_freeargs(transp, xdr_result, &result)) {
+     if (!svc_freeargs(transp, xdr_result, (char *)&result)) {
 	  krb5_klog_syslog(LOG_ERR, "WARNING! Unable to free results, "
 		 "continuing.");
      }
      return;
 }
 
+#if 0
+
 static int
 check_rpcsec_auth(struct svc_req *rqstp)
 {
@@ -361,3 +362,4 @@ gss_to_krb5_name_1(struct svc_req *rqstp, krb5_context ctx, gss_name_t gss_name,
      free(str);
      return success;
 }
+#endif
--- a/src/kadmin/server/ovsec_kadmd.c
+++ b/src/kadmin/server/ovsec_kadmd.c
@@ -45,16 +45,17 @@
 #include <unistd.h>
 #include <netinet/in.h>
 #include <netdb.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <gssapi/gssapi.h>
 #include "gssapiP_krb5.h" /* for kg_get_context */
-#include <gssrpc/auth_gssapi.h>
 #include <kadm5/admin.h>
 #include <kadm5/kadm_rpc.h>
 #include <adm_proto.h>
 #include "kdb_kt.h"  /* for krb5_ktkdb_set_context */
 #include <string.h>
 #include <kdb_log.h>
+#include <rpc/rpcsec_gss.h>
+#include <kadm5/kadm_rpc.h>
 
 #include "misc.h"
 #include "auth.h"
@@ -343,20 +344,21 @@ main(int argc, char *argv[])
     OM_uint32 minor_status;
     gss_buffer_desc in_buf;
     gss_OID nt_krb5_name_oid = (gss_OID)GSS_KRB5_NT_PRINCIPAL_NAME;
-    auth_gssapi_name names[4];
+    char *names[4];
     kadm5_config_params params;
     verto_ctx *vctx;
     const char *pid_file = NULL;
     char **db_args = NULL, **tmpargs;
     const char *acl_file;
     int ret, i, db_args_size = 0, proponly = 0;
+    char **tmp_srv_names;
+    krb5_principal princ;
+    char *pos;
 
     setlocale(LC_ALL, "");
     setvbuf(stderr, NULL, _IONBF, 0);
 
-    names[0].name = names[1].name = names[2].name = names[3].name = NULL;
-    names[0].type = names[1].type = names[2].type = names[3].type =
-        nt_krb5_name_oid;
+    names[0] = names[1] = names[2] = names[3] = NULL;
 
     progname = (strrchr(argv[0], '/') != NULL) ? strrchr(argv[0], '/') + 1 :
         argv[0];
@@ -465,28 +467,88 @@ main(int argc, char *argv[])
                            "iprop_enable is true"));
     }
 
-    ret = setup_loop(&params, proponly, &vctx);
+    ret = kadm5_get_adm_host_srv_names(context, params.realm, &tmp_srv_names);
     if (ret)
-        fail_to_start(ret, _("initializing network"));
+        fail_to_start(ret, _("building GSSAPI auth names"));
+    names[0] = strdup(tmp_srv_names[0]);
+    if (names[0] == NULL)
+        fail_to_start(ENOMEM, _("copying GSSAPI auth names"));
+    free_srv_names(tmp_srv_names);
+    tmp_srv_names = NULL;
 
-    names[0].name = build_princ_name(KADM5_ADMIN_SERVICE, params.realm);
-    names[1].name = build_princ_name(KADM5_CHANGEPW_SERVICE, params.realm);
-    if (names[0].name == NULL || names[1].name == NULL)
-        fail_to_start(0, _("Cannot build GSSAPI auth names"));
+    ret = kadm5_get_cpw_host_srv_names(context, params.realm, &tmp_srv_names);
+    if (ret)
+        fail_to_start(ret, _("building GSSAPI auth names"));
+    names[1] = strdup(tmp_srv_names[0]);
+    if (names[1] == NULL)
+        fail_to_start(ENOMEM, _("copying GSSAPI auth names"));
+    free_srv_names(tmp_srv_names);
+    tmp_srv_names = NULL;
+
+    if (params.iprop_enabled == TRUE) {
+        ret = kadm5_get_kiprop_host_srv_names(context, params.realm,
+                                              &tmp_srv_names);
+        if (ret)
+            fail_to_start(ret, _("building GSSAPI auth names"));
+        names[2] = strdup(tmp_srv_names[0]);
+        if (names[2] == NULL)
+            fail_to_start(ENOMEM, _("copying GSSAPI auth names"));
+        free_srv_names(tmp_srv_names);
+        tmp_srv_names = NULL;
+
+        /*
+         * For hierarchical incremental propagation we need kadmind
+         * on slave KDCs to register local hostbased kiprop service principal,
+         * not the one for admin server. For least surprise on upgrade we
+         * register both.
+         */
+        ret = krb5_sname_to_principal(context, NULL, KADM5_KIPROP_HOST_SERVICE,
+                                      KRB5_NT_SRV_HST, &princ);
+        if (ret)
+            fail_to_start(ret, _("building GSSAPI auth names"));
+        ret = krb5_unparse_name(context, princ, &names[3]);
+        if (ret)
+            fail_to_start(ret, _("building GSSAPI auth names"));
+        if ((pos = strchr(names[3], '@')) != NULL)
+            *pos = '\0';
+        if ((pos = strchr(names[3], '/')) != NULL)
+            *pos = '@';
+    }
 
     ret = setup_kdb_keytab();
     if (ret)
         fail_to_start(0, _("Cannot set up KDB keytab"));
-
+#if 0
     if (svcauth_gssapi_set_names(names, 2) == FALSE)
         fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+#endif
+    if (!rpc_gss_set_svc_name(names[0], "kerberos_v5", 0, KADM, KADMVERS))
+        fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+    if (!rpc_gss_set_svc_name(names[1], "kerberos_v5", 0, KADM, KADMVERS))
+        fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+    if (params.iprop_enabled == TRUE) {
+        if (!rpc_gss_set_svc_name(names[2], "kerberos_v5", 0,
+                                  KRB5_IPROP_PROG, KRB5_IPROP_VERS))
+            fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+        if (strcmp(names[2], names[3])){
+            if (!rpc_gss_set_svc_name(names[3], "kerberos_v5", 0,
+                                      KRB5_IPROP_PROG, KRB5_IPROP_VERS))
+                fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+
+        }
+    }
 
     /* if set_names succeeded, this will too */
-    in_buf.value = names[1].name;
-    in_buf.length = strlen(names[1].name) + 1;
+    in_buf.value = names[1];
+    in_buf.length = strlen(names[1]);
     (void)gss_import_name(&minor_status, &in_buf, nt_krb5_name_oid,
                           &gss_changepw_name);
 
+    ret = setup_loop(&params, proponly, &vctx);
+    if (ret)
+        fail_to_start(ret, _("initializing network"));
+
+#if 0
     svcauth_gssapi_set_log_badauth2_func(log_badauth, NULL);
     svcauth_gssapi_set_log_badverf_func(log_badverf, NULL);
     svcauth_gssapi_set_log_miscerr_func(log_miscerr, NULL);
@@ -497,6 +559,7 @@ main(int argc, char *argv[])
 
     if (svcauth_gss_set_svc_name(GSS_C_NO_NAME) != TRUE)
         fail_to_start(0, _("Cannot initialize GSSAPI service name"));
+#endif
 
     acl_file = (*params.acl_file != '\0') ? params.acl_file : NULL;
     ret = auth_init(context, acl_file);
@@ -547,14 +610,16 @@ main(int argc, char *argv[])
     krb5_klog_syslog(LOG_INFO, _("finished, exiting"));
 
     /* Clean up memory, etc */
+#if 0
     svcauth_gssapi_unset_names();
+#endif
     kadm5_destroy(global_server_handle);
     loop_free(vctx);
     auth_fini(context);
     (void)gss_release_name(&minor_status, &gss_changepw_name);
     (void)gss_release_name(&minor_status, &gss_oldchangepw_name);
     for (i = 0; i < 4; i++)
-        free(names[i].name);
+        free(names[i]);
 
     krb5_klog_close(context);
     krb5_free_context(context);
--- a/src/kadmin/server/server_stubs.c
+++ b/src/kadmin/server/server_stubs.c
@@ -14,6 +14,8 @@
 #include <kadm5/server_internal.h>
 #include <syslog.h>
 #include <adm_proto.h>  /* krb5_klog_syslog */
+#include <rpc/rpcsec_gss.h>
+#include <rpc/svc_mt.h>
 #include "misc.h"
 #include "auth.h"
 
@@ -21,19 +23,24 @@ extern gss_name_t                       gss_changepw_name;
 extern gss_name_t                       gss_oldchangepw_name;
 extern void *                           global_server_handle;
 
-#define CHANGEPW_SERVICE(rqstp)                                         \
-    (cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred), gss_changepw_name) | \
-     (gss_oldchangepw_name &&                                           \
-      cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred),             \
+#define CHANGEPW_SERVICE(rqstp)                                     \
+    (cmp_gss_names_rel_1(acceptor_name(rqstp), gss_changepw_name) | \
+     (gss_oldchangepw_name &&                                       \
+      cmp_gss_names_rel_1(acceptor_name(rqstp),                     \
                           gss_oldchangepw_name)))
 
+/*
+ * Non-public function from rpc/libc found on Solaris. We (mis)use it to fetch
+ * gss_ctx_id_t established earlier. See ticket_is_initial() for more details.
+ */
+extern SVCAUTH *__svc_get_svcauth(SVCXPRT *);
 
 static int gss_to_krb5_name(kadm5_server_handle_t handle,
                             gss_name_t gss_name, krb5_principal *princ);
 
 static int gss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str);
 
-static gss_name_t acceptor_name(gss_ctx_id_t context);
+static gss_name_t acceptor_name(struct svc_req *rqstp);
 
 gss_name_t rqst2name(struct svc_req *rqstp);
 
@@ -107,6 +114,8 @@ static kadm5_ret_t new_server_handle(krb5_ui_4 api_version,
                                      *out_handle)
 {
     kadm5_server_handle_t handle;
+    gss_name_t name = NULL;
+    OM_uint32 min_stat;
 
     *out_handle = NULL;
 
@@ -117,13 +126,18 @@ static kadm5_ret_t new_server_handle(krb5_ui_4 api_version,
     *handle = *(kadm5_server_handle_t)global_server_handle;
     handle->api_version = api_version;
 
-    if (! gss_to_krb5_name(handle, rqst2name(rqstp),
-                           &handle->current_caller)) {
+    if (!(name = rqst2name(rqstp))) {
         free(handle);
         return KADM5_FAILURE;
     }
+    if (! gss_to_krb5_name(handle, name, &handle->current_caller)) {
+        free(handle);
+        gss_release_name(&min_stat, &name);
+        return KADM5_FAILURE;
+    }
 
     *out_handle = handle;
+    gss_release_name(&min_stat, &name);
     return 0;
 }
 
@@ -182,38 +196,54 @@ int setup_gss_names(struct svc_req *rqstp,
                     gss_buffer_desc *client_name,
                     gss_buffer_desc *server_name)
 {
-    OM_uint32 maj_stat, min_stat;
-    gss_name_t server_gss_name;
+    OM_uint32 min_stat;
+    gss_name_t name = NULL;
+    rpc_gss_rawcred_t *raw_cred;
 
-    if (gss_name_to_string(rqst2name(rqstp), client_name) != 0)
-        return -1;
-    maj_stat = gss_inquire_context(&min_stat, rqstp->rq_svccred, NULL,
-                                   &server_gss_name, NULL, NULL, NULL,
-                                   NULL, NULL);
-    if (maj_stat != GSS_S_COMPLETE) {
-        gss_release_buffer(&min_stat, client_name);
-        gss_release_name(&min_stat, &server_gss_name);
+    if (!(name = rqst2name(rqstp))) {
         return -1;
     }
-    if (gss_name_to_string(server_gss_name, server_name) != 0) {
-        gss_release_buffer(&min_stat, client_name);
-        gss_release_name(&min_stat, &server_gss_name);
+    if (gss_name_to_string(name, client_name) != 0) {
+        gss_release_name(&min_stat, &name);
         return -1;
     }
-    gss_release_name(&min_stat, &server_gss_name);
+    gss_release_name(&min_stat, &name);
+
+    rpc_gss_getcred(rqstp, &raw_cred, NULL, NULL);
+    server_name->value = strdup(raw_cred->svc_principal);
+    if (server_name->value == NULL) {
+        gss_release_buffer(&min_stat, client_name);
+        return -1;
+    }
+    server_name->length = strlen(raw_cred->svc_principal);
+
     return 0;
 }
 
-static gss_name_t acceptor_name(gss_ctx_id_t context)
+static gss_name_t acceptor_name(struct svc_req *rqstp)
 {
     OM_uint32 maj_stat, min_stat;
-    gss_name_t name;
+    gss_name_t name = NULL;
+    rpc_gss_rawcred_t *raw_cred;
+    gss_buffer_desc name_buff;
 
-    maj_stat = gss_inquire_context(&min_stat, context, NULL, &name,
-                                   NULL, NULL, NULL, NULL, NULL);
-    if (maj_stat != GSS_S_COMPLETE)
-        return NULL;
-    return name;
+    rpc_gss_getcred(rqstp, &raw_cred, NULL, NULL);
+    name_buff.value = raw_cred->svc_principal;
+    name_buff.length = strlen(raw_cred->svc_principal);
+    maj_stat = gss_import_name(&min_stat, &name_buff,
+        (gss_OID) gss_nt_krb5_name, &name);
+    if (maj_stat != GSS_S_COMPLETE) {
+        gss_release_buffer(&min_stat, &name_buff);
+        return (NULL);
+    }
+    maj_stat = gss_display_name(&min_stat, name, &name_buff, NULL);
+    if (maj_stat != GSS_S_COMPLETE) {
+        gss_release_buffer(&min_stat, &name_buff);
+      return (NULL);
+    }
+    gss_release_buffer(&min_stat, &name_buff);
+
+     return name;
 }
 
 static int gss_to_krb5_name(kadm5_server_handle_t handle,
@@ -269,7 +299,7 @@ static kadm5_ret_t
 stub_setup(krb5_ui_4 api_version, struct svc_req *rqstp, krb5_principal princ,
            kadm5_server_handle_t *handle_out, krb5_ui_4 *api_version_out,
            gss_buffer_t client_name_out, gss_buffer_t service_name_out,
-           char **princ_str_out)
+           char **princ_str_out, gss_name_t *name_out)
 {
     kadm5_ret_t ret;
 
@@ -292,6 +322,11 @@ stub_setup(krb5_ui_4 api_version, struct svc_req *rqstp, krb5_principal princ,
         if (krb5_unparse_name((*handle_out)->context, princ, princ_str_out))
             return KADM5_BAD_PRINCIPAL;
     }
+    if (name_out !=  NULL) { 
+        *name_out = rqst2name(rqstp);
+        if (*name_out == NULL)	
+		return KADM5_FAILURE;
+    }
 
     return KADM5_OK;
 }
@@ -299,7 +334,8 @@ stub_setup(krb5_ui_4 api_version, struct svc_req *rqstp, krb5_principal princ,
 /* Perform common cleanup for server stub functions. */
 static void
 stub_cleanup(kadm5_server_handle_t handle, char *princ_str,
-             gss_buffer_t client_name, gss_buffer_t service_name)
+             gss_buffer_t client_name, gss_buffer_t service_name,
+	     gss_name_t name)
 {
     OM_uint32 minor_stat;
 
@@ -308,6 +344,8 @@ stub_cleanup(kadm5_server_handle_t handle, char *princ_str,
     free(princ_str);
     gss_release_buffer(&minor_stat, client_name);
     gss_release_buffer(&minor_stat, service_name);
+    if (name)
+        gss_release_name(&minor_stat, &name);
 }
 
 static krb5_boolean
@@ -345,15 +383,64 @@ changepw_not_self(kadm5_server_handle_t handle, struct svc_req *rqstp,
                                 princ);
 }
 
+/*
+ * There is a small difference between Solaris and upstream MIT kerberos here.
+ * The devil hides in definition of svc_req structure, which looks on Solaris
+ * as follows:
+ * 	struct svc_req {
+ *		rpcprog_t	rq_prog;
+ *		rpcvers_t	rq_vers;
+ *		rpcproc_t	rq_proc;
+ *		struct opaque_auth rq_cred;
+ *		caddr_t		rq_clntcred;
+ *		SVCXPRT		*rq_xprt;
+ *		bslabel_t	*rq_label;
+ * 	};
+ *
+ * The same structure defined by native kerberos RPC:
+ *	struct svc_req {
+ *		rpcprog_t		rq_prog;
+ *		rpcvers_t		rq_vers;
+ *		rpcproc_t		rq_proc;
+ *		struct opaque_auth rq_cred;
+ *		void *		rq_clntcred;
+ *		void *		rq_svccred;
+ *		void *		rq_clntname;
+ *		SVCXPRT		*rq_xprt;
+ *		...
+ *	};
+ *
+ * They are almost same. The deal breaker here is rq_svccred member found in
+ * upstream. Upstream uses rq_svccred to convey GSS context id between parties.
+ *
+ * On Solaris the GSS context ID hides beneath RPC API surface in GSS params
+ * attached to SVCAUTH (Authenticator). In order to reach it we deliberately
+ * ask non public __svc_get_svcauth() to do it for us.
+ */
 static krb5_boolean
 ticket_is_initial(struct svc_req *rqstp)
 {
     OM_uint32 status, minor_stat;
-    krb5_flags flags;
+    krb5_flags flags = 0;
+    rpc_gss_rawcred_t *gss_rcred;
+    rpc_gss_error_t gss_error;
+    gss_ctx_id_t context_handle;
+    SVCAUTH *auth;
 
-    status = gss_krb5_get_tkt_flags(&minor_stat, rqstp->rq_svccred, &flags);
+    if (!rpc_gss_getcred(rqstp, &gss_rcred, NULL, NULL)) {
+	rpc_gss_get_error(&gss_error);
+	return 0;
+    }
+
+    auth = __svc_get_svcauth(rqstp->rq_xprt);
+    if (auth == NULL)
+	return 0;
+
+    context_handle = auth->svc_gss_parms.context;
+    status = gss_krb5_get_tkt_flags(&minor_stat, context_handle, &flags);
     if (status != GSS_S_COMPLETE)
-        return 0;
+	    return 0;
+
     return (flags & TKT_FLG_INITIAL) != 0;
 }
 
@@ -441,10 +528,11 @@ create_principal_2_svc(cprinc_arg *arg, generic_ret *ret,
     gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->rec.principal,
                            &handle, &ret->api_version, &client_name,
-                           &service_name, &prime_arg);
+                           &service_name, &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -468,7 +556,7 @@ create_principal_2_svc(cprinc_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -481,10 +569,11 @@ create_principal3_2_svc(cprinc3_arg *arg, generic_ret *ret,
     gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->rec.principal,
                            &handle, &ret->api_version, &client_name,
-                           &service_name, &prime_arg);
+                           &service_name, &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -508,7 +597,7 @@ create_principal3_2_svc(cprinc3_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -536,10 +625,11 @@ delete_principal_2_svc(dprinc_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -572,7 +662,7 @@ delete_principal_2_svc(dprinc_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -585,10 +675,11 @@ modify_principal_2_svc(mprinc_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->rec.principal,
                            &handle, &ret->api_version, &client_name,
-                           &service_name, &prime_arg);
+                           &service_name, &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -620,7 +711,7 @@ modify_principal_2_svc(mprinc_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -635,10 +726,11 @@ rename_principal_2_svc(rprinc_arg *arg, generic_ret *ret,
     const char                  *errmsg = NULL;
     size_t                      tlen1, tlen2, clen, slen;
     char                        *tdots1, *tdots2, *cdots, *sdots;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -704,7 +796,7 @@ rename_principal_2_svc(rprinc_arg *arg, generic_ret *ret,
 exit_func:
     free(prime_arg1);
     free(prime_arg2);
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -716,10 +808,11 @@ get_principal_2_svc(gprinc_arg *arg, gprinc_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -745,7 +838,7 @@ get_principal_2_svc(gprinc_arg *arg, gprinc_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -757,10 +850,11 @@ get_princs_2_svc(gprincs_arg *arg, gprincs_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -788,7 +882,7 @@ get_princs_2_svc(gprincs_arg *arg, gprincs_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -801,10 +895,11 @@ chpass_principal_2_svc(chpass_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -838,7 +933,7 @@ chpass_principal_2_svc(chpass_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -851,10 +946,11 @@ chpass_principal3_2_svc(chpass3_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -891,7 +987,7 @@ chpass_principal3_2_svc(chpass3_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -904,10 +1000,11 @@ setkey_principal_2_svc(setkey_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -940,7 +1037,7 @@ setkey_principal_2_svc(setkey_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -953,10 +1050,11 @@ setkey_principal3_2_svc(setkey3_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -990,7 +1088,7 @@ setkey_principal3_2_svc(setkey3_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1003,10 +1101,11 @@ setkey_principal4_2_svc(setkey4_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1039,7 +1138,7 @@ setkey_principal4_2_svc(setkey4_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1074,10 +1173,11 @@ chrand_principal_2_svc(chrand_arg *arg, chrand_ret *ret, struct svc_req *rqstp)
     int                         nkeys;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1116,7 +1216,7 @@ chrand_principal_2_svc(chrand_arg *arg, chrand_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1131,10 +1231,11 @@ chrand_principal3_2_svc(chrand3_arg *arg, chrand_ret *ret,
     int                         nkeys;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1175,7 +1276,7 @@ chrand_principal3_2_svc(chrand3_arg *arg, chrand_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1187,10 +1288,11 @@ create_policy_2_svc(cpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1217,7 +1319,7 @@ create_policy_2_svc(cpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1229,10 +1331,11 @@ delete_policy_2_svc(dpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1257,7 +1360,7 @@ delete_policy_2_svc(dpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1269,10 +1372,11 @@ modify_policy_2_svc(mpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1298,7 +1402,7 @@ modify_policy_2_svc(mpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1312,12 +1416,13 @@ get_policy_2_svc(gpol_arg *arg, gpol_ret *ret, struct svc_req *rqstp)
     kadm5_principal_ent_rec     caller_ent;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL, *cpolicy = NULL;
+    gss_name_t                  name = NULL;
 
     memset(&caller_ent, 0, sizeof(caller_ent));
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1351,7 +1456,7 @@ get_policy_2_svc(gpol_arg *arg, gpol_ret *ret, struct svc_req *rqstp)
 
 exit_func:
     (void)kadm5_free_principal_ent(handle->lhandle, &caller_ent);
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1363,10 +1468,11 @@ get_pols_2_svc(gpols_arg *arg, gpols_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1393,7 +1499,7 @@ get_pols_2_svc(gpols_arg *arg, gpols_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1406,7 +1512,7 @@ get_privs_2_svc(krb5_ui_4 *arg, getprivs_ret *ret, struct svc_req *rqstp)
     const char                     *errmsg = NULL;
 
     ret->code = stub_setup(*arg, rqstp, NULL, &handle, &ret->api_version,
-                           &client_name, &service_name, NULL);
+                           &client_name, &service_name, NULL, NULL);
     if (ret->code)
         goto exit_func;
 
@@ -1421,7 +1527,7 @@ get_privs_2_svc(krb5_ui_4 *arg, getprivs_ret *ret, struct svc_req *rqstp)
         krb5_free_error_message(handle->context, errmsg);
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, NULL);
     return TRUE;
 }
 
@@ -1434,10 +1540,11 @@ purgekeys_2_svc(purgekeys_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     kadm5_server_handle_t       handle;
 
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1460,7 +1567,7 @@ purgekeys_2_svc(purgekeys_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1472,10 +1579,11 @@ get_strings_2_svc(gstrings_arg *arg, gstrings_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1498,7 +1606,7 @@ get_strings_2_svc(gstrings_arg *arg, gstrings_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1510,10 +1618,11 @@ set_string_2_svc(sstring_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1536,7 +1645,7 @@ set_string_2_svc(sstring_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1551,7 +1660,7 @@ init_2_svc(krb5_ui_4 *arg, generic_ret *ret, struct svc_req *rqstp)
     char *cdots, *sdots;
 
     ret->code = stub_setup(*arg, rqstp, NULL, &handle, &ret->api_version,
-                           &client_name, &service_name, NULL);
+                           &client_name, &service_name, NULL, NULL);
     if (ret->code)
         goto exit_func;
 
@@ -1577,18 +1686,27 @@ init_2_svc(krb5_ui_4 *arg, generic_ret *ret, struct svc_req *rqstp)
         krb5_free_error_message(handle->context, errmsg);
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, NULL);
     return TRUE;
 }
 
 gss_name_t
 rqst2name(struct svc_req *rqstp)
 {
+    OM_uint32 maj_stat, min_stat;
+    gss_name_t name;
+    rpc_gss_rawcred_t * raw_cred;
+    gss_buffer_desc name_buff;
 
-    if (rqstp->rq_cred.oa_flavor == RPCSEC_GSS)
-        return rqstp->rq_clntname;
-    else
-        return rqstp->rq_clntcred;
+    rpc_gss_getcred(rqstp, &raw_cred, NULL, NULL);
+    name_buff.value = raw_cred->client_principal->name;
+    name_buff.length = raw_cred->client_principal->len;
+    maj_stat = gss_import_name(&min_stat, &name_buff,
+                               (gss_OID) GSS_C_NT_EXPORT_NAME, &name);
+    if (maj_stat != GSS_S_COMPLETE) {
+        return (NULL);
+    }
+    return (name);
 }
 
 bool_t
@@ -1600,10 +1718,11 @@ get_principal_keys_2_svc(getpkeys_arg *arg, getpkeys_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1644,6 +1763,6 @@ get_principal_keys_2_svc(getpkeys_arg *arg, getpkeys_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
--- a/src/kprop/kpropd.c
+++ b/src/kprop/kpropd.c
@@ -611,13 +611,14 @@ full_resync(CLIENT *clnt)
 
     memset(&clnt_res, 0, sizeof(clnt_res));
 
-    status = clnt_call(clnt, IPROP_FULL_RESYNC_EXT, (xdrproc_t)xdr_u_int32,
-                       &vers, (xdrproc_t)xdr_kdb_fullresync_result_t,
-                       &clnt_res, full_resync_timeout);
+    status = clnt_call(clnt, IPROP_FULL_RESYNC_EXT, (xdrproc_t)xdr_u_int,
+                       (caddr_t)&vers, (xdrproc_t)xdr_kdb_fullresync_result_t,
+                       (caddr_t)&clnt_res, full_resync_timeout);
     if (status == RPC_PROCUNAVAIL) {
         status = clnt_call(clnt, IPROP_FULL_RESYNC, (xdrproc_t)xdr_void,
-                           &vers, (xdrproc_t)xdr_kdb_fullresync_result_t,
-                           &clnt_res, full_resync_timeout);
+                           (caddr_t)&vers,
+			   (xdrproc_t)xdr_kdb_fullresync_result_t,
+                           (caddr_t)&clnt_res, full_resync_timeout);
     }
 
     return (status == RPC_SUCCESS) ? &clnt_res : NULL;
--- a/src/lib/Makefile.in
+++ b/src/lib/Makefile.in
@@ -1,5 +1,5 @@
 mydir=lib
-SUBDIRS=crypto krb5 gssapi rpc kdb kadm5 apputils krad
+SUBDIRS=crypto krb5 gssapi kdb kadm5 apputils krad
 WINSUBDIRS=crypto krb5 gssapi
 BUILDTOP=$(REL)..
 
--- a/src/lib/apputils/net-server.c
+++ b/src/lib/apputils/net-server.c
@@ -33,7 +33,7 @@
 #include "port-sockets.h"
 #include "socket-utils.h"
 
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 
 #ifdef HAVE_NETINET_IN_H
 #include <sys/types.h>
@@ -195,6 +195,9 @@ struct connection {
 #define FREE_SET_DATA(set)                                      \
     (free(set.data), set.data = 0, set.max = 0, set.n = 0)
 
+#define EMPTY(set)                                              \
+    (set.n == 0)
+
 /*
  * N.B.: The Emacs cc-mode indentation code seems to get confused if
  * the macro argument here is one word only.  So use "unsigned short"
@@ -582,6 +585,113 @@ static void process_tcp_connection_write(verto_ctx *ctx, verto_ev *ev);
 static void accept_rpc_connection(verto_ctx *ctx, verto_ev *ev);
 static void process_rpc_connection(verto_ctx *ctx, verto_ev *ev);
 
+static int
+set_tli_opt(int fd, int level, int name, const void *val, unsigned int val_len)
+{
+    struct t_optmgmt req, rep;
+    struct opthdr *opt;
+    char reqbuf[256];
+
+    if (val_len + sizeof (struct opthdr) > sizeof (reqbuf))
+        return -1;
+
+    opt = (struct opthdr *) reqbuf;
+    opt->level = level;
+    opt->name = name;
+    opt->len = val_len;
+
+    memcpy(reqbuf + sizeof (struct opthdr), val, val_len);
+
+    req.flags = T_NEGOTIATE;
+    req.opt.len = sizeof (struct opthdr) + opt->len;
+    req.opt.buf = (char *) opt;
+
+    rep.flags = 0;
+    rep.opt.buf = reqbuf;
+    rep.opt.maxlen = sizeof (reqbuf);
+
+    if (t_optmgmt(fd, &req, &rep) < 0 || rep.flags != T_SUCCESS) {
+        t_error("t_optmgmt");
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Create a tli/xti endpoint and bind it to addr. Ensure the file descriptor
+ * will work with select. Set cloexec, reuseaddr, and if applicable v6-only.
+ * Does not call listen().  Returns -1 on failure after logging an error.
+ */
+static int
+create_server_endpoint(struct netconfig *nconf, struct sockaddr *sock_address,
+		       const char *prog, int *err)
+{
+    int fd, on;
+    struct t_info tinfo;
+    struct t_bind *tbind;
+
+    /* open transport endpoint */
+    fd = t_open(nconf->nc_device, O_RDWR, &tinfo);
+    if (fd == -1) {
+        *err = errno;
+        com_err(prog, errno, _("unable to open connection for ADMIN server"));
+        return -1;
+    }
+    set_cloexec_fd(fd);
+
+    /* ensure fd works with select */
+    if (fd >= FD_SETSIZE) {
+	*err = errno;
+        t_close(fd);
+        com_err(prog, 0, _("endpoint fd number %d too high"), fd);
+        return -1;
+    }
+
+    /* set SO_REUSEADDR */
+    on = 1;
+    if (set_tli_opt(fd, SOL_SOCKET, SO_REUSEADDR , &on, sizeof (on)) < 0)
+        com_err(prog, errno,
+                _("cannot enable SO_REUSEADDR on fd %d"), fd);
+
+    /* set IPv6-only as appropriate */
+    if (sock_address->sa_family == AF_INET6) {
+#ifdef IPV6_V6ONLY
+        if (set_tli_opt(fd, IPPROTO_IPV6, IPV6_V6ONLY , &on, sizeof (on)) < 0)
+            com_err(prog, errno, _("cannot set IPV6_V6ONLY on fd %d"), fd);
+#else
+        krb5_klog_syslog(LOG_INFO, _("no IPV6_V6ONLY socket option support"));
+#endif /* IPV6_V6ONLY */
+    }
+
+    /* bind fd to specified address */
+    tbind = (struct t_bind *)t_alloc(fd, T_BIND, T_ADDR);
+    if (tbind == NULL) {
+	*err = ENOMEM;
+	com_err(prog, errno, _("Cannot allocate t_bind structure."));
+        t_close(fd);
+        return -1;
+    }
+
+    tbind->qlen = 64;    /* Chosen Arbitrarily, from svc_generic.c */
+    tbind->addr.len = (sock_address->sa_family == AF_INET6) ?
+                      sizeof (struct sockaddr_in6) :
+                      sizeof (struct sockaddr_in);
+    memcpy(tbind->addr.buf, sock_address, tbind->addr.len);
+
+    if (t_bind(fd, tbind, NULL) < 0) {
+	*err = errno;
+        com_err(prog, errno, _("Cannot bind transport endpoint to %s"),
+                paddr(sock_address));
+        t_free(tbind, T_BIND);
+        t_close(fd);
+        return -1;
+    }
+    t_free(tbind, T_BIND);
+
+    return fd;
+}
+
 /*
  * Create a socket and bind it to addr.  Ensure the socket will work with
  * select().  Set the socket cloexec, reuseaddr, and if applicable v6-only.
@@ -695,18 +805,37 @@ setup_socket(struct bind_address *ba, struct sockaddr *sock_address,
              void *handle, const char *prog, verto_ctx *ctx,
              int tcp_listen_backlog, verto_callback vcb, enum conn_type ctype)
 {
-    krb5_error_code ret;
+    krb5_error_code ret = 0;
     struct connection *conn;
     verto_ev_flag flags;
     verto_ev *ev = NULL;
     int sock = -1;
+    struct netconfig *nconf = NULL;
+    int err;
 
     krb5_klog_syslog(LOG_DEBUG, _("Setting up %s socket for address %s"),
                      bind_type_names[ba->type], paddr(sock_address));
 
     /* Create the socket. */
-    ret = create_server_socket(sock_address, bind_socktypes[ba->type], prog,
-                               &sock);
+    if (ba->type == RPC) {
+        switch (sock_address->sa_family) {
+        case AF_INET:
+            nconf = getnetconfigent("tcp");
+            break;
+        case AF_INET6:
+            nconf = getnetconfigent("tcp6");
+            break;
+        default:
+            ret = EAFNOSUPPORT;
+            goto cleanup;
+        }
+        sock = create_server_endpoint(nconf, sock_address, prog, &err);
+	if (sock == -1)
+	    ret = err;
+    } else {
+	ret = create_server_socket(sock_address, bind_socktypes[ba->type], prog,
+				   &sock);
+    }
     if (ret)
         goto cleanup;
 
@@ -763,23 +892,33 @@ setup_socket(struct bind_address *ba, struct sockaddr *sock_address,
 
     if (ba->type == RPC) {
         conn = verto_get_private(ev);
-        conn->transp = svctcp_create(sock, 0, 0);
+        errno = 0;
+        conn->transp = svc_tli_create(sock, nconf, NULL, 0, 0);
         if (conn->transp == NULL) {
-            ret = errno;
-            krb5_klog_syslog(LOG_ERR, _("Cannot create RPC service: %s"),
-                             strerror(ret));
+            ret = (errno != 0) ? errno : EINVAL;
+            krb5_klog_syslog(LOG_ERR,
+                             _("Cannot create RPC service; continuing"));
             goto cleanup;
         }
 
-        ret = svc_register(conn->transp, ba->rpc_svc_data.prognum,
-                           ba->rpc_svc_data.versnum, ba->rpc_svc_data.dispatch,
-                           0);
-        if (!ret) {
-            ret = errno;
-            krb5_klog_syslog(LOG_ERR, _("Cannot register RPC service: %s"),
-                             strerror(ret));
+        if (!svc_reg(conn->transp, ba->rpc_svc_data.prognum,
+                     ba->rpc_svc_data.versnum, ba->rpc_svc_data.dispatch,
+                     nconf)) {
+            ret = (errno != 0) ? errno : EINVAL;
+            krb5_klog_syslog(LOG_ERR,
+                             _("Cannot register RPC prog %d vers %d on %s; "
+                               "continuing"),
+                             (int) ba->rpc_svc_data.prognum,
+                             (int) ba->rpc_svc_data.versnum,
+                             nconf->nc_netid);
             goto cleanup;
         }
+        krb5_klog_syslog(LOG_INFO,
+                         _("listening on fd %d: %s address %s:%hd "
+                           "(RPC prog %d vers %d)"),
+                         sock, nconf->nc_netid, ba->address, ba->port,
+                         (int) ba->rpc_svc_data.prognum,
+                         (int) ba->rpc_svc_data.versnum);
     }
 
     ev = NULL;
@@ -791,6 +930,8 @@ cleanup:
         close(sock);
     if (ev != NULL)
         verto_del(ev);
+    if (nconf != NULL)
+	freenetconfigent(nconf);
     return ret;
 }
 
--- a/src/lib/kadm5/Makefile.in
+++ b/src/lib/kadm5/Makefile.in
@@ -21,6 +21,7 @@ SRCS =	kadm_err.c \
 	$(srcdir)/chpass_util.c \
 	$(srcdir)/alt_prof.c \
 	$(srcdir)/str_conv.c \
+	$(srcdir)/kadm_host_srv_names.c \
 	$(srcdir)/logger.c
 
 OBJS =	kadm_err.$(OBJEXT) \
@@ -30,6 +31,7 @@ OBJS =	kadm_err.$(OBJEXT) \
 	chpass_util.$(OBJEXT) \
 	alt_prof.$(OBJEXT) \
 	str_conv.$(OBJEXT) \
+	kadm_host_srv_names.$(OBJEXT) \
 	logger.$(OBJEXT)
 
 STLIBOBJS = \
@@ -40,6 +42,7 @@ STLIBOBJS = \
 	chpass_util.o \
 	alt_prof.o \
 	str_conv.o \
+	kadm_host_srv_names.o \
 	logger.o
 
 HDRDIR=$(BUILDTOP)/include/kadm5
--- a/src/lib/kadm5/admin.h
+++ b/src/lib/kadm5/admin.h
@@ -42,7 +42,7 @@
 #define __KADM5_ADMIN_H__
 
 #include        <sys/types.h>
-#include        <gssrpc/rpc.h>
+#include        <rpc/rpc.h>
 #include        <krb5.h>
 #include        <kdb.h>
 #include        <com_err.h>
@@ -64,7 +64,9 @@ KADM5INT_BEGIN_DECLS
 #define KADM5_ADMIN_SERVICE     "kadmin/admin"
 #define KADM5_CHANGEPW_SERVICE  "kadmin/changepw"
 #define KADM5_HIST_PRINCIPAL    "kadmin/history"
-#define KADM5_KIPROP_HOST_SERVICE "kiprop"
+
+#define KADM5_KIPROP_HOST_SERVICE	"kiprop"
+#define	KADM5_ADMIN_HOST_SERVICE	"kadmin"
 
 typedef krb5_principal  kadm5_princ_t;
 typedef char            *kadm5_policy_t;
@@ -462,6 +464,21 @@ kadm5_ret_t    kadm5_free_key_data(void *server_handle,
 kadm5_ret_t    kadm5_free_name_list(void *server_handle, char **names,
                                     int count);
 
+kadm5_ret_t
+kadm5_get_adm_host_srv_names(krb5_context context,
+		             const char *realm, char ***host_service_names);
+
+kadm5_ret_t
+kadm5_get_cpw_host_srv_names(krb5_context context,
+		             const char *realm, char ***host_service_names);
+
+kadm5_ret_t
+kadm5_get_kiprop_host_srv_names(krb5_context context,
+		             const char *realm, char ***host_service_names);
+
+void
+free_srv_names(char **srv_names);
+
 krb5_error_code kadm5_init_krb5_context (krb5_context *);
 
 krb5_error_code kadm5_init_iprop(void *server_handle, char **db_args);
--- a/src/lib/kadm5/alt_prof.c
+++ b/src/lib/kadm5/alt_prof.c
@@ -517,6 +517,7 @@ krb5_error_code kadm5_get_config_params(krb5_context context,
     kadm5_config_params params, empty_params;
     krb5_boolean bvalue;
     krb5_error_code ret = 0;
+    krb5_deltat sunw_iprop;
 
     memset(&params, 0, sizeof(params));
     memset(&empty_params, 0, sizeof(empty_params));
@@ -761,10 +762,17 @@ krb5_error_code kadm5_get_config_params(krb5_context context,
         params.mask |= KADM5_CONFIG_IPROP_ENABLED;
         params.iprop_enabled = params_in->iprop_enabled;
     } else {
-        if (aprofile &&
-            !krb5_aprof_get_boolean(aprofile, hierarchy, TRUE, &bvalue)) {
-            params.iprop_enabled = bvalue;
-            params.mask |= KADM5_CONFIG_IPROP_ENABLED;
+        if (aprofile) {
+            if(!krb5_aprof_get_boolean(aprofile, hierarchy, TRUE, &bvalue)) {
+                params.iprop_enabled = bvalue;
+                params.mask |= KADM5_CONFIG_IPROP_ENABLED;
+            } else {
+                hierarchy[2] = KRB5_CONF_SUNW_DBPROP_ENABLE;
+                if(!krb5_aprof_get_boolean(aprofile, hierarchy, TRUE, &bvalue)){
+                    params.iprop_enabled = bvalue;
+                    params.mask |= KADM5_CONFIG_IPROP_ENABLED;
+                }
+            }
         }
     }
 
@@ -790,25 +798,38 @@ krb5_error_code kadm5_get_config_params(krb5_context context,
     } else {
         params.iprop_ulogsize = 0;
         hierarchy[2] = KRB5_CONF_IPROP_ULOGSIZE;
-        if (aprofile != NULL &&
-            !krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue) &&
-            ivalue > 0)
-            params.iprop_ulogsize = ivalue;
-        hierarchy[2] = KRB5_CONF_IPROP_MASTER_ULOGSIZE;
-        if (params.iprop_ulogsize == 0 && aprofile != NULL &&
-            !krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue) &&
-            ivalue > 0)
-            params.iprop_ulogsize = ivalue;
+        if (aprofile != NULL) {
+            if (!krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue)) {
+                if (ivalue <= 0)
+                    params.iprop_ulogsize = DEF_ULOGENTRIES;
+                else
+                    params.iprop_ulogsize = ivalue;
+                params.mask |= KADM5_CONFIG_ULOG_SIZE;
+            } else {
+                hierarchy[2] = KRB5_CONF_SUNW_DBPROP_MASTER_ULOGSIZE;
+                if (!krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue)) {
+                    if (ivalue <= 0)
+                        params.iprop_ulogsize = DEF_ULOGENTRIES;
+                    else
+                        params.iprop_ulogsize = ivalue;
+                    params.mask |= KADM5_CONFIG_ULOG_SIZE;
+                }
+            }
+        }
         if (params.iprop_ulogsize == 0)
             params.iprop_ulogsize = DEF_ULOGENTRIES;
     }
     params.mask |= KADM5_CONFIG_ULOG_SIZE;
 
+    GET_DELTAT_PARAM(iprop_poll_time, KADM5_CONFIG_POLL_TIME,
+                     KRB5_CONF_SUNW_DBPROP_SLAVE_POLL, 2 * 60); /* 2m */
+    sunw_iprop = params.iprop_poll_time;
+
     GET_DELTAT_PARAM(iprop_poll_time, KADM5_CONFIG_POLL_TIME,
                      KRB5_CONF_IPROP_REPLICA_POLL, -1);
     if (params.iprop_poll_time == -1) {
         GET_DELTAT_PARAM(iprop_poll_time, KADM5_CONFIG_POLL_TIME,
-                         KRB5_CONF_IPROP_SLAVE_POLL, 2 * 60);
+                         KRB5_CONF_IPROP_SLAVE_POLL, sunw_iprop);
     }
 
     *params_out = params;
--- a/src/lib/kadm5/clnt/Makefile.in
+++ b/src/lib/kadm5/clnt/Makefile.in
@@ -7,12 +7,11 @@ LIBMAJOR=12
 LIBMINOR=0
 STOBJLISTS=../OBJS.ST OBJS.ST
 SHLIB_EXPDEPS=\
-	$(TOPLIBD)/libgssrpc$(SHLIBEXT) \
 	$(TOPLIBD)/libgssapi_krb5$(SHLIBEXT) \
 	$(TOPLIBD)/libkrb5$(SHLIBEXT) \
 	$(TOPLIBD)/libk5crypto$(SHLIBEXT) \
 	$(COM_ERR_DEPLIB) $(SUPPORT_LIBDEP)
-SHLIB_EXPLIBS=-lgssrpc -lgssapi_krb5 -lkrb5 -lk5crypto $(SUPPORT_LIB) $(COM_ERR_LIB) $(LIBS)
+SHLIB_EXPLIBS=-lgssapi_krb5 -lkrb5 -lk5crypto $(SUPPORT_LIB) $(COM_ERR_LIB) $(LIBS)
 RELDIR=kadm5/clnt
 
 ##DOSBUILDTOP = ..\..\..
--- a/src/lib/kadm5/clnt/client_init.c
+++ b/src/lib/kadm5/clnt/client_init.c
@@ -44,12 +44,12 @@
 #include <iprop_hdr.h>
 #include "iprop.h"
 
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <gssapi/gssapi.h>
 #include <gssapi/gssapi_krb5.h>
-#include <gssrpc/auth_gssapi.h>
 
 #define ADM_CCACHE  "/tmp/ovsec_adm.XXXXXX"
+#define KADMIND_CONNECT_TIMEOUT	25
 
 enum init_type { INIT_PASS, INIT_SKEY, INIT_CREDS, INIT_ANONYMOUS };
 
@@ -138,6 +138,377 @@ kadm5_init_with_skey(krb5_context context, char *client_name,
                     server_handle);
 }
 
+/*
+ * Open an fd for the given address and connect asynchronously. Wait
+ * KADMIND_CONNECT_TIMEOUT seconds or till it succeeds. If it succeeds
+ * change fd to blocking and return it, else return -1.
+ */
+static int
+get_connection(struct netconfig *nconf, struct netbuf netaddr)
+{
+	struct t_info tinfo;
+	struct t_call sndcall;
+	struct t_call *rcvcall = NULL;
+	int connect_time;
+	int flags;
+	int fd;
+
+	(void) memset(&tinfo, 0, sizeof (tinfo));
+
+	/* we'l open with O_NONBLOCK and avoid an fcntl */
+	fd = t_open(nconf->nc_device, O_RDWR | O_NONBLOCK, &tinfo);
+	if (fd == -1) {
+		return (-1);
+	}
+
+	if (t_bind(fd, (struct t_bind *)NULL, (struct t_bind *)NULL) == -1) {
+		(void) t_close(fd);
+		return (-1);
+	}
+
+	/* we can't connect unless fd is in IDLE state */
+	if (t_getstate(fd) != T_IDLE) {
+		(void) t_close(fd);
+		return (-1);
+	}
+
+	/* setup connect parameters */
+	netaddr.len = netaddr.maxlen = __rpc_get_a_size(tinfo.addr);
+	sndcall.addr = netaddr;
+	sndcall.opt.len = sndcall.udata.len = 0;
+
+	/* we wait for KADMIND_CONNECT_TIMEOUT seconds from now */
+	connect_time = time(NULL) + KADMIND_CONNECT_TIMEOUT;
+	if (t_connect(fd, &sndcall, rcvcall) != 0) {
+		if (t_errno != TNODATA) {
+			(void) t_close(fd);
+			return (-1);
+		}
+	}
+
+	/* loop till success or timeout */
+	for (;;) {
+		if (t_rcvconnect(fd, rcvcall) == 0)
+			break;
+
+		if (t_errno != TNODATA || time(NULL) > connect_time) {
+			/* we have either timed out or caught an error */
+			(void) t_close(fd);
+			if (rcvcall != NULL)
+				t_free((char *)rcvcall, T_CALL);
+			return (-1);
+		}
+		sleep(1);
+	}
+
+	/* make the fd blocking (synchronous) */
+	flags = fcntl(fd, F_GETFL, 0);
+	(void) fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);
+	if (rcvcall != NULL)
+		t_free((char *)rcvcall, T_CALL);
+	return (fd);
+}
+
+/*
+ * Wrapper over clnt_tli_create.
+ * Opens a connection to host:port and calls clnt_tli_create.
+ * Returns a client handle or NULL on failure.
+ */
+static CLIENT*
+clnt_create_with_port(const char *host, int port,
+		      const rpcprog_t prog, const rpcvers_t vers)
+{
+	struct netbuf netaddr;
+	struct hostent *hp;
+	int fd;
+	struct sockaddr_in addr;
+	struct sockaddr_in *sin;
+	struct netconfig *nconf;
+	void *handlep = NULL;
+	CLIENT *clnt = NULL;
+
+	hp = gethostbyname(host);
+	if (hp == (struct hostent *)NULL) {
+		goto cleanup;
+	}
+
+	memset(&addr, 0, sizeof (addr));
+	addr.sin_family = hp->h_addrtype;
+	(void) memcpy((char *)&addr.sin_addr, (char *)hp->h_addr,
+		    sizeof (addr.sin_addr));
+	addr.sin_port = htons((ushort_t)port);
+	sin = &addr;
+	if ((handlep = setnetconfig()) == (void *) NULL) {
+		goto cleanup;
+	}
+
+	while (nconf = getnetconfig(handlep)) {
+		if ((nconf->nc_semantics == NC_TPI_COTS_ORD) &&
+		    (strcmp(nconf->nc_protofmly, NC_INET) == 0) &&
+		    (strcmp(nconf->nc_proto, NC_TCP) == 0))
+			break;
+	}
+
+	if (nconf == (struct netconfig *)NULL)
+		goto cleanup;
+
+	/* Transform addr to netbuf */
+	(void) memset(&netaddr, 0, sizeof (netaddr));
+	netaddr.buf = (char *)sin;
+
+	/* get an fd connected to the given address */
+	fd =  get_connection(nconf, netaddr);
+	if (fd == -1) {
+		goto cleanup;
+	}
+
+	clnt = clnt_tli_create(fd, nconf, NULL, prog, vers, 0, 0);
+	if (clnt == NULL) {
+		clnt_pcreateerror("ERROR:");
+		(void) t_close(fd);
+		goto cleanup;
+	}
+	/*
+	 * The rpc-handle was created on an fd opened and connected
+	 * by us, so we have to explicitly tell rpc to close it.
+	 */
+	if (clnt_control(clnt, CLSET_FD_CLOSE, NULL) != TRUE) {
+		clnt_destroy(clnt);
+		clnt = NULL;
+		(void) t_close(fd);
+	}
+
+cleanup:
+	if (handlep != (void *) NULL)
+		(void) endnetconfig(handlep);
+
+	return (clnt);
+}
+
+/*
+ * Open an RPCSEC_GSS connection and
+ * get a client handle to use for future RPCSEC calls.
+ *
+ * This function is only used when changing passwords and
+ * the kpasswd_protocol is RPCSEC_GSS
+ */
+static int
+_kadm5_initialize_rpcsec_gss_handle(kadm5_server_handle_t handle,
+				    char *client_name,
+				    char *service_name)
+{
+	int code = 0;
+	generic_ret r = { 0, 0 };
+	char *ccname_orig = NULL;
+	boolean_t iprop_enable = B_FALSE;
+	char mech[] = "kerberos_v5";
+	gss_OID mech_oid;
+	gss_OID_set_desc oid_set;
+	gss_name_t gss_client;
+	gss_buffer_desc input_name;
+	gss_cred_id_t gss_client_creds = GSS_C_NO_CREDENTIAL;
+	rpc_gss_options_req_t   options_req;
+	rpc_gss_options_ret_t   options_ret;
+	rpc_gss_service_t service = rpc_gss_svc_privacy;
+	OM_uint32 gssstat, minor_stat;
+	enum clnt_stat rpc_err_code;
+	char *server;
+	int port;
+	struct timeval timeout;
+
+        /* service name is service/host */
+        server = strpbrk(service_name, "/");
+        if (!server) {
+		code = KADM5_BAD_SERVER_NAME;
+		goto cleanup;
+        }
+
+	/* but rpc_gss_secreate expects service@host */
+	*server++ = '@';
+
+ 	/*
+	 * If the service_name and client_name are iprop-centric
+	 * use iprop service; otherwise use kadmin service.
+	 */
+	if ((strstr(service_name, KIPROP_SVC_NAME) != NULL) &&
+	    (strstr(client_name, KIPROP_SVC_NAME) != NULL)) {
+		iprop_enable = B_TRUE;
+	}
+
+	/*
+	 * iprop fallback logic:
+	 *    - if iprop_port is configured, connect to iprop_port
+	 *    - if not, query remote rpc/bind
+	 *    - if that fails, try consuming iprop service on kadmin port
+	 */
+	if (iprop_enable && handle->params.iprop_port != 0){
+		port = handle->params.iprop_port;
+		handle->clnt = clnt_create_with_port(server, port,
+						     KRB5_IPROP_PROG,
+						     KRB5_IPROP_VERS);
+	} else if (iprop_enable && handle->params.iprop_port == 0) {
+		/* using remote rpc/bind first */
+		handle->clnt = clnt_create(server, KRB5_IPROP_PROG,
+					   KRB5_IPROP_VERS, NC_TCP);
+		if (handle->clnt == NULL) {
+			/* possible rpc/bind failure, try kadmin port */
+			port = handle->params.kadmind_port;
+			handle->clnt = clnt_create_with_port(server, port,
+							     KRB5_IPROP_PROG,
+							     KRB5_IPROP_VERS);
+		}
+	} else {
+		/* kadmin service */
+		port = handle->params.kadmind_port;
+		handle->clnt = clnt_create_with_port(server, port,
+				                     KADM, KADMVERS);
+	}
+
+	if (handle->clnt == NULL) {
+		code = KADM5_RPC_ERROR;
+		goto error;
+	}
+
+	/* Set a one-hour timeout. */
+	timeout.tv_sec = 3600;
+	timeout.tv_usec = 0;
+	(void)clnt_control(handle->clnt, CLSET_TIMEOUT, (char *)&timeout);
+
+	handle->lhandle->clnt = handle->clnt;
+
+	/* now that handle->clnt is set, we can check the handle */
+	if (code = _kadm5_check_handle((void *) handle))
+		goto error;
+
+	/*
+	 * The RPC connection is open; establish the GSS-API
+	 * authentication context.
+	 */
+	/* use the kadm5 cache */
+	gssstat = gss_krb5_ccache_name(&minor_stat, handle->cache_name,
+                                       (const char **)&ccname_orig);
+	if (gssstat != GSS_S_COMPLETE) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+	if (ccname_orig)
+		ccname_orig = strdup(ccname_orig);
+
+	input_name.value = client_name;
+	input_name.length = strlen((char *)input_name.value) + 1;
+	gssstat = gss_import_name(&minor_stat, &input_name,
+				(gss_OID)gss_nt_krb5_name, &gss_client);
+	if (gssstat != GSS_S_COMPLETE) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+
+	if (!rpc_gss_mech_to_oid(mech, (rpc_gss_OID *)&mech_oid)) {
+		(void) gss_release_name(&minor_stat, &gss_client);
+		goto error;
+	}
+
+	oid_set.count = 1;
+	oid_set.elements = mech_oid;
+
+	gssstat = gss_acquire_cred(&minor_stat, gss_client, 0,
+				&oid_set, GSS_C_INITIATE,
+				&gss_client_creds, NULL, NULL);
+	(void) gss_release_name(&minor_stat, &gss_client);
+	if (gssstat != GSS_S_COMPLETE) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+	options_req.my_cred = gss_client_creds;
+	options_req.req_flags = GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG;
+	options_req.time_req = 0;
+	options_req.input_channel_bindings = NULL;
+#ifndef INIT_TEST
+	gss_client_creds = GSS_C_NO_CREDENTIAL;
+	handle->clnt->cl_auth = rpc_gss_seccreate(handle->clnt,
+						service_name,
+						mech,
+						service,
+						NULL,
+						&options_req,
+						&options_ret);
+#endif /* ! INIT_TEST */
+
+	if (ccname_orig) {
+		gssstat = gss_krb5_ccache_name(&minor_stat, ccname_orig, NULL);
+		free(ccname_orig);
+		if (gssstat != GSS_S_COMPLETE) {
+			code = KADM5_GSS_ERROR;
+			goto error;
+		}
+	} else {
+		gssstat = gss_krb5_ccache_name(&minor_stat, NULL, NULL);
+		if (gssstat != GSS_S_COMPLETE) {
+			code = KADM5_GSS_ERROR;
+			goto error;
+		}
+	}
+
+#ifndef INIT_TEST
+	if (handle->clnt->cl_auth == NULL) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+#endif /* ! INIT_TEST */
+
+	/*
+	 * Bypass the remainder of the code and return straightaway
+	 * if the gss service requested is kiprop
+	 */
+	if (iprop_enable == B_TRUE) {
+		code = 0;
+		goto cleanup;
+	}
+
+	if (init_2(&handle->api_version, &r, handle->clnt)) {
+		code = KADM5_RPC_ERROR;
+		goto error;
+	}
+
+    /* Drop down to v3 wire protocol if server does not support v4 */
+    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
+        handle->api_version == KADM5_API_VERSION_4) {
+        handle->api_version = KADM5_API_VERSION_3;
+	memset(&r, 0, sizeof(generic_ret));
+	if (init_2(&handle->api_version, &r, handle->clnt)) {
+            code = KADM5_RPC_ERROR;
+            goto error;
+        }
+    }
+
+    /* Drop down to v2 wire protocol if server does not support v3 */
+    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
+        handle->api_version == KADM5_API_VERSION_3) {
+        handle->api_version = KADM5_API_VERSION_2;
+	memset(&r, 0, sizeof(generic_ret));
+	if (init_2(&handle->api_version, &r, handle->clnt)) {
+            code = KADM5_RPC_ERROR;
+            goto error;
+        }
+    }
+
+	if (r.code) {
+		code = r.code;
+		goto error;
+	}
+error:
+cleanup:
+	/*
+	 * gss_client_creds is freed only when there is an error condition,
+	 * given that rpc_gss_seccreate() will assign the cred pointer to the
+	 * my_cred member in the auth handle's private data structure.
+	 */
+	if (code && (gss_client_creds != GSS_C_NO_CREDENTIAL))
+		(void) gss_release_cred(&minor_stat, &gss_client_creds);
+
+	return (code);
+}
+
 static kadm5_ret_t
 free_handle(kadm5_server_handle_t handle)
 {
@@ -170,7 +541,7 @@ free_handle(kadm5_server_handle_t handle)
 
 static kadm5_ret_t
 init_any(krb5_context context, char *client_name, enum init_type init_type,
-         char *pass, krb5_ccache ccache_in, char *service_name,
+         char *pass, krb5_ccache ccache_in, char *svcname_in,
          kadm5_config_params *params_in, krb5_ui_4 struct_version,
          krb5_ui_4 api_version, char **db_args, void **server_handle)
 {
@@ -180,12 +551,12 @@ init_any(krb5_context context, char *client_name, enum init_type init_type,
     rpcprog_t rpc_prog;
     rpcvers_t rpc_vers;
     krb5_principal client = NULL, server = NULL;
-    struct timeval timeout;
 
     kadm5_server_handle_t handle = NULL;
     kadm5_config_params params_local;
 
     krb5_error_code code;
+    char svcname[BUFSIZ];
     generic_ret r = { 0, 0 };
 
     initialize_ovk_error_table();
@@ -247,102 +618,29 @@ init_any(krb5_context context, char *client_name, enum init_type init_type,
     if (init_type == INIT_SKEY && client->realm.length == 0)
         client->type = KRB5_NT_SRV_HST;
 
-    /*
-     * Get credentials.  Also does some fallbacks in case kadmin/fqdn
-     * principal doesn't exist.
-     */
-    code = get_init_creds(handle, client, init_type, pass, ccache_in,
-                          service_name, handle->params.realm, &server);
-    if (code)
-        goto cleanup;
-
-    /* If the service_name and client_name are iprop-centric, use the iprop
-     * port and RPC identifiers. */
-    iprop_enable = (service_name != NULL &&
-                    strstr(service_name, KIPROP_SVC_NAME) != NULL &&
-                    strstr(client_name, KIPROP_SVC_NAME) != NULL);
-    if (iprop_enable) {
-        port = handle->params.iprop_port;
-        rpc_prog = KRB5_IPROP_PROG;
-        rpc_vers = KRB5_IPROP_VERS;
+    /* NULL svcname means use host-based. */
+    if (svcname_in == NULL) {
+        code = kadm5_get_admin_service_name(handle->context,
+                                            handle->params.realm,
+                                            svcname, sizeof(svcname));
+        if (code)
+            goto cleanup;
     } else {
-        port = handle->params.kadmind_port;
-        rpc_prog = KADM;
-        rpc_vers = KADMVERS;
+        strncpy(svcname, svcname_in, sizeof(svcname));
+        svcname[sizeof(svcname)-1] = '\0';
     }
 
-    code = connect_to_server(handle->params.admin_server, port, &fd);
+    /* Get credentials. */
+    code = get_init_creds(handle, client, init_type, pass, ccache_in,
+                          svcname, handle->params.realm, &server);
     if (code)
         goto cleanup;
 
-    handle->clnt = clnttcp_create(NULL, rpc_prog, rpc_vers, &fd, 0, 0);
-    if (handle->clnt == NULL) {
-        code = KADM5_RPC_ERROR;
-#ifdef DEBUG
-        clnt_pcreateerror("clnttcp_create");
-#endif
+    code = _kadm5_initialize_rpcsec_gss_handle(handle, client_name,
+                                               svcname);
+    if (code != 0) {
         goto cleanup;
     }
-
-    /* Set a one-hour timeout. */
-    timeout.tv_sec = 3600;
-    timeout.tv_usec = 0;
-    (void)clnt_control(handle->clnt, CLSET_TIMEOUT, &timeout);
-
-    handle->client_socket = fd;
-    handle->lhandle->clnt = handle->clnt;
-    handle->lhandle->client_socket = fd;
-
-    /*
-     * The RPC connection is open; establish the GSS-API
-     * authentication context.
-     */
-    code = setup_gss(handle, params_in,
-                     (init_type == INIT_CREDS) ? client : NULL, server);
-    if (code)
-        goto cleanup;
-
-    /*
-     * Bypass the remainder of the code and return straight away
-     * if the gss service requested is kiprop
-     */
-    if (iprop_enable) {
-        code = 0;
-        *server_handle = handle;
-        handle = NULL;
-        goto cleanup;
-    }
-
-    if (init_2(&handle->api_version, &r, handle->clnt)) {
-        code = KADM5_RPC_ERROR;
-#ifdef DEBUG
-        clnt_perror(handle->clnt, "init_2 null resp");
-#endif
-        goto cleanup;
-    }
-    /* Drop down to v3 wire protocol if server does not support v4 */
-    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
-        handle->api_version == KADM5_API_VERSION_4) {
-        handle->api_version = KADM5_API_VERSION_3;
-        memset(&r, 0, sizeof(generic_ret));
-        if (init_2(&handle->api_version, &r, handle->clnt)) {
-            code = KADM5_RPC_ERROR;
-            goto cleanup;
-        }
-    }
-    /* Drop down to v2 wire protocol if server does not support v3 */
-    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
-        handle->api_version == KADM5_API_VERSION_3) {
-        handle->api_version = KADM5_API_VERSION_2;
-        memset(&r, 0, sizeof(generic_ret));
-        if (init_2(&handle->api_version, &r, handle->clnt)) {
-            code = KADM5_RPC_ERROR;
-            goto cleanup;
-        }
-    }
-    if (r.code) {
-        code = r.code;
-        goto cleanup;
     }
 
     *server_handle = handle;
@@ -356,16 +654,14 @@ cleanup:
     return code;
 }
 
-/* Get initial credentials for authenticating to server.  Perform fallback from
- * kadmin/fqdn to kadmin/admin if svcname_in is NULL. */
+/* Get initial credentials for authenticating to server. */
 static kadm5_ret_t
 get_init_creds(kadm5_server_handle_t handle, krb5_principal client,
                enum init_type init_type, char *pass, krb5_ccache ccache_in,
-               char *svcname_in, char *realm, krb5_principal *server_out)
+               char *svcname, char *realm, krb5_principal *server_out)
 {
     kadm5_ret_t code;
     krb5_ccache ccache = NULL;
-    char *svcname, svcbuf[BUFSIZ];
 
     *server_out = NULL;
 
@@ -404,20 +700,9 @@ get_init_creds(kadm5_server_handle_t handle, krb5_principal client,
     }
     handle->lhandle->cache_name = handle->cache_name;
 
-    svcname = (svcname_in != NULL) ? svcname_in : KADM5_ADMIN_SERVICE;
+    svcname = (svcname != NULL) ? svcname : KADM5_ADMIN_SERVICE;
     code = gic_iter(handle, init_type, ccache, client, pass, svcname, realm,
                     server_out);
-    if ((code == KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN
-         || code == KRB5_CC_NOTFOUND) && svcname_in == NULL) {
-        /* Retry with host-based service principal. */
-        code = kadm5_get_admin_service_name(handle->context,
-                                            handle->params.realm,
-                                            svcbuf, sizeof(svcbuf));
-        if (code)
-            goto error;
-        code = gic_iter(handle, init_type, ccache, client, pass, svcbuf, realm,
-                        server_out);
-    }
     /* Improved error messages */
     if (code == KRB5KRB_AP_ERR_BAD_INTEGRITY) code = KADM5_BAD_PASSWORD;
     if (code == KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN)
@@ -642,6 +927,27 @@ rpc_auth(kadm5_server_handle_t handle, kadm5_config_params *params_in,
          gss_cred_id_t gss_client_creds, gss_name_t gss_target)
 {
     OM_uint32 gssstat, minor_stat;
+    gss_buffer_desc buf;
+    rpc_gss_options_req_t options_req;
+    rpc_gss_options_ret_t options_ret;
+
+    if (gss_display_name(&minor_stat, gss_target, &buf, NULL) != GSS_S_COMPLETE)
+	    return;
+
+    options_req.my_cred = gss_client_creds;
+    options_req.req_flags = GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG;
+    options_req.time_req = 0;
+    options_req.input_channel_bindings = NULL;
+    handle->clnt->cl_auth = rpc_gss_seccreate(handle->clnt,
+		                              (char*) buf.value,
+					      "kerberos_v5",
+					      rpc_gss_svc_privacy,
+					      NULL,
+					      &options_req,
+					      &options_ret);
+
+    gss_release_buffer(&minor_stat, &buf);
+#if 0
     struct rpc_gss_sec sec;
 
     /* Allow unauthenticated option for testing. */
@@ -676,6 +982,7 @@ rpc_auth(kadm5_server_handle_t handle, kadm5_config_params *params_in,
                                                GSS_C_MUTUAL_FLAG
                                                | GSS_C_REPLAY_FLAG,
                                                0, NULL, NULL, NULL);
+#endif
 }
 
 kadm5_ret_t
--- a/src/lib/kadm5/clnt/client_principal.c
+++ b/src/lib/kadm5/clnt/client_principal.c
@@ -5,7 +5,7 @@
  * $Header$
  */
 
-#include    <gssrpc/rpc.h>
+#include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
 #ifdef HAVE_MEMORY_H
--- a/src/lib/kadm5/clnt/client_rpc.c
+++ b/src/lib/kadm5/clnt/client_rpc.c
@@ -1,5 +1,5 @@
 /* -*- mode: c; c-file-style: "bsd"; indent-tabs-mode: t -*- */
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <kadm5/kadm_rpc.h>
 #include <krb5.h>
 #include <kadm5/admin.h>
--- a/src/lib/kadm5/clnt/clnt_policy.c
+++ b/src/lib/kadm5/clnt/clnt_policy.c
@@ -5,7 +5,7 @@
  * $Header$
  */
 
-#include    <gssrpc/rpc.h>
+#include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
 #include    "client_internal.h"
--- a/src/lib/kadm5/clnt/clnt_privs.c
+++ b/src/lib/kadm5/clnt/clnt_privs.c
@@ -7,7 +7,7 @@
  *
  */
 
-#include    <gssrpc/rpc.h>
+#include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
 #include    "client_internal.h"
--- a/src/lib/kadm5/deps
+++ b/src/lib/kadm5/deps
@@ -98,6 +98,20 @@ str_conv.so str_conv.po $(OUTPRE)str_conv.$(OBJEXT): \
   $(top_srcdir)/include/krb5/plugin.h $(top_srcdir)/include/port-sockets.h \
   $(top_srcdir)/include/socket-utils.h admin_internal.h \
   str_conv.c
+kadm_host_srv_names.so kadm_host_srv_names.po $(OUTPRE)kadm_host_srv_names.$(OBJEXT): \
+  $(BUILDTOP)/include/autoconf.h $(BUILDTOP)/include/gssapi/gssapi.h \
+  $(BUILDTOP)/include/kadm5/chpass_util_strings.h $(BUILDTOP)/include/kadm5/kadm_err.h \
+  $(BUILDTOP)/include/krb5/krb5.h $(BUILDTOP)/include/osconf.h \
+  $(BUILDTOP)/include/profile.h $(COM_ERR_DEPS) $(srcdir)/../krb5/os/os-proto.h \
+  $(top_srcdir)/include/fake-addrinfo.h $(top_srcdir)/include/k5-buf.h \
+  $(top_srcdir)/include/k5-err.h $(top_srcdir)/include/k5-gmt_mktime.h \
+  $(top_srcdir)/include/k5-int-pkinit.h $(top_srcdir)/include/k5-int.h \
+  $(top_srcdir)/include/k5-platform.h $(top_srcdir)/include/k5-plugin.h \
+  $(top_srcdir)/include/k5-thread.h $(top_srcdir)/include/k5-trace.h \
+  $(top_srcdir)/include/kdb.h $(top_srcdir)/include/krb5.h \
+  $(top_srcdir)/include/krb5/authdata_plugin.h $(top_srcdir)/include/krb5/locate_plugin.h \
+  $(top_srcdir)/include/krb5/plugin.h $(top_srcdir)/include/port-sockets.h \
+  $(top_srcdir)/include/socket-utils.h admin.h kadm_host_srv_names.c
 logger.so logger.po $(OUTPRE)logger.$(OBJEXT): $(BUILDTOP)/include/autoconf.h \
   $(BUILDTOP)/include/krb5/krb5.h $(BUILDTOP)/include/osconf.h \
   $(BUILDTOP)/include/profile.h $(COM_ERR_DEPS) $(top_srcdir)/include/adm_proto.h \
--- a/src/lib/kadm5/kadm_rpc.h
+++ b/src/lib/kadm5/kadm_rpc.h
@@ -2,7 +2,7 @@
 #ifndef __KADM_RPC_H__
 #define __KADM_RPC_H__
 
-#include <gssrpc/types.h>
+#include <rpc/types.h>
 
 #include	<krb5.h>
 #include	<kadm5/admin.h>
@@ -405,4 +405,8 @@ extern bool_t xdr_kadm5_key_data ();
 extern bool_t xdr_getpkeys_arg ();
 extern bool_t xdr_getpkeys_ret ();
 
+/* Solaris libc doesn't define 32 bit version of xdr_int and xdr_u_int */
+#define	xdr_int32 xdr_int
+#define	xdr_u_int32 xdr_u_int
+
 #endif /* __KADM_RPC_H__ */
--- a/src/lib/kadm5/kadm_rpc_xdr.c
+++ b/src/lib/kadm5/kadm_rpc_xdr.c
@@ -3,7 +3,7 @@
  * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved
  */
 
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <krb5.h>
 #include <errno.h>
 #include <kadm5/admin.h>
--- a/src/lib/kadm5/server_internal.h
+++ b/src/lib/kadm5/server_internal.h
@@ -266,4 +266,8 @@ k5_kadm5_hook_rename (krb5_context context,
 
 /** @}*/
 
+/* Solaris Kerberos: symbols available in libkadm5srv_mit */
+extern void xdralloc_create(XDR *xdrs, enum xdr_op op);
+extern caddr_t xdralloc_getdata(XDR *xdrs);
+
 #endif /* __KADM5_SERVER_INTERNAL_H__ */
--- a/src/lib/kadm5/srv/Makefile.in
+++ b/src/lib/kadm5/srv/Makefile.in
@@ -14,13 +14,12 @@ LIBMINOR=0
 STOBJLISTS=../OBJS.ST OBJS.ST
 
 SHLIB_EXPDEPS=\
-	$(TOPLIBD)/libgssrpc$(SHLIBEXT) \
 	$(TOPLIBD)/libgssapi_krb5$(SHLIBEXT) \
 	$(TOPLIBD)/libkdb5$(SHLIBEXT) \
 	$(TOPLIBD)/libkrb5$(SHLIBEXT) \
 	$(TOPLIBD)/libk5crypto$(SHLIBEXT) \
 	$(COM_ERR_DEPLIB) $(SUPPORT_LIBDEP)
-SHLIB_EXPLIBS =	-lgssrpc -lgssapi_krb5 -lkdb5 $(KDB5_DB_LIB) -lkrb5 \
+SHLIB_EXPLIBS =	-lgssapi_krb5 -lkdb5 $(KDB5_DB_LIB) -lkrb5 \
 		-lk5crypto $(SUPPORT_LIB) $(COM_ERR_LIB) @GEN_LIB@ $(LIBS)
 RELDIR=kadm5/srv
 
@@ -37,6 +36,8 @@ SRCS =	$(srcdir)/pwqual.c \
 	$(srcdir)/server_init.c \
 	$(srcdir)/svr_iters.c \
 	$(srcdir)/svr_chpass_util.c \
+	$(srcdir)/xdr_alloc.c \
+	$(srcdir)/dyn.c \
 	$(srcdir)/adb_xdr.c 
 
 OBJS =	pwqual.$(OBJEXT) \
@@ -52,6 +53,8 @@ OBJS =	pwqual.$(OBJEXT) \
 	server_init.$(OBJEXT) \
 	svr_iters.$(OBJEXT) \
 	svr_chpass_util.$(OBJEXT) \
+	xdr_alloc.$(OBJEXT) \
+	dyn.$(OBJEXT) \
 	adb_xdr.$(OBJEXT) 
 
 STLIBOBJS = \
@@ -68,6 +71,8 @@ STLIBOBJS = \
 	server_init.o \
 	svr_iters.o \
 	svr_chpass_util.o \
+	xdr_alloc.o \
+	dyn.o \
 	adb_xdr.o
 
 all-unix: all-liblinks
--- a/src/lib/kadm5/srv/adb_xdr.c
+++ b/src/lib/kadm5/srv/adb_xdr.c
@@ -7,7 +7,7 @@
 
 #include <sys/types.h>
 #include <krb5.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include	"server_internal.h"
 #include "admin_xdr.h"
 #ifdef HAVE_MEMORY_H
--- a/src/lib/kadm5/srv/server_init.c
+++ b/src/lib/kadm5/srv/server_init.c
@@ -212,8 +212,7 @@ kadm5_ret_t kadm5_init(krb5_context context, char *client_name, char *pass,
 
 #define IPROP_REQUIRED_PARAMS                   \
     (KADM5_CONFIG_IPROP_ENABLED |               \
-     KADM5_CONFIG_IPROP_LOGFILE |               \
-     KADM5_CONFIG_IPROP_PORT)
+     KADM5_CONFIG_IPROP_LOGFILE)
 
     if ((handle->params.mask & REQUIRED_PARAMS) != REQUIRED_PARAMS) {
         ret = KADM5_MISSING_CONF_PARAMS;
--- a/src/lib/kadm5/t_kadm5.py
+++ b/src/lib/kadm5/t_kadm5.py
@@ -40,6 +40,6 @@ realm.run([kadminl, 'addprinc', '-pw', 'admin', 'admin/none'])
 realm.run([kadminl, 'addprinc', '-pw', 'us3r', '-policy', 'minlife-pol',
            'user'])
 
-realm.run(['./t_kadm5srv', 'srv'])
-realm.run(['./t_kadm5clnt', 'clnt'])
+#realm.run(['./t_kadm5srv', 'srv'])
+#realm.run(['./t_kadm5clnt', 'clnt'])
 success('kadm5 API tests')
--- a/src/lib/kdb/Makefile.in
+++ b/src/lib/kdb/Makefile.in
@@ -14,9 +14,8 @@ RELDIR=kdb
 
 SHLIB_EXPDEPS = \
 	$(TOPLIBD)/libk5crypto$(SHLIBEXT) \
-	$(TOPLIBD)/libgssrpc$(SHLIBEXT) \
 	$(TOPLIBD)/libkrb5$(SHLIBEXT)
-SHLIB_EXPLIBS=-lgssrpc -lkrb5 -lk5crypto $(COM_ERR_LIB) $(SUPPORT_LIB) $(DL_LIB) $(LIBS)
+SHLIB_EXPLIBS=-lkrb5 -lk5crypto $(COM_ERR_LIB) $(SUPPORT_LIB) $(DL_LIB) $(LIBS)
 
 adb_err.$(OBJEXT): adb_err.c
 adb_err.c adb_err.h: $(srcdir)/adb_err.et
--- a/src/lib/kdb/iprop_xdr.c
+++ b/src/lib/kdb/iprop_xdr.c
@@ -9,6 +9,7 @@
 #pragma GCC diagnostic ignored "-Wunused-variable"
 #endif
 
+#if 0
 static bool_t
 xdr_int16_t (XDR *xdrs, int16_t *objp)
 {
@@ -38,6 +39,7 @@ xdr_uint32_t (XDR *xdrs, uint32_t *objp)
         return FALSE;
     return TRUE;
 }
+#endif
 
 bool_t
 xdr_utf8str_t (XDR *xdrs, utf8str_t *objp)
--- a/src/lib/krb5/os/changepw.c
+++ b/src/lib/krb5/os/changepw.c
@@ -57,7 +57,7 @@ struct sendto_callback_context {
  * Wrapper function for the two backends
  */
 
-static krb5_error_code
+krb5_error_code
 locate_kpasswd(krb5_context context, const krb5_data *realm,
                struct serverlist *serverlist)
 {
--- a/src/lib/krb5/os/locate_kdc.c
+++ b/src/lib/krb5/os/locate_kdc.c
@@ -833,6 +833,14 @@ k5_locate_kdc(krb5_context context, const krb5_data *realm,
     return k5_locate_server(context, realm, serverlist, stype, no_udp);
 }
 
+krb5_error_code
+k5_locate_kadmin(krb5_context context, const krb5_data *realm,
+                 struct serverlist *serverlist)
+{
+    return k5_locate_server(context, realm, serverlist, locate_service_kadmin,
+                            1);
+}
+
 krb5_boolean
 k5_kdc_is_primary(krb5_context context, const krb5_data *realm,
                   struct server_entry *server)
--- a/src/lib/krb5/os/sn2princ.c
+++ b/src/lib/krb5/os/sn2princ.c
@@ -98,6 +98,7 @@ expand_hostname(krb5_context context, const char *host, krb5_boolean use_dns,
 
     canonhost = host;
     if (use_dns) {
+#if 0 /* force DNS lookup */
         /* Try a forward lookup of the hostname. */
         memset(&hint, 0, sizeof(hint));
         hint.ai_flags = AI_CANONNAME;
@@ -116,6 +117,7 @@ expand_hostname(krb5_context context, const char *host, krb5_boolean use_dns,
             if (!err)
                 canonhost = namebuf;
         }
+#endif 0
     }
 
     /* If we didn't use DNS and the name is just one component, try to add a
--- a/src/lib/rpc/xdr_alloc.c
+++ b/src/lib/rpc/xdr_alloc.c
@@ -35,18 +35,23 @@
  * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved.
  */
 
-#include <gssrpc/types.h>
-#include <gssrpc/xdr.h>
+#include <sys/types.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+#include <inttypes.h>
 #include "dyn.h"
 
 static bool_t	xdralloc_putlong(XDR *, long *);
-static bool_t	xdralloc_putbytes(XDR *, caddr_t, unsigned int);
+static bool_t	xdralloc_putbytes(XDR *, caddr_t, int);
 static unsigned int	xdralloc_getpos(XDR *);
 static rpc_inline_t *	xdralloc_inline(XDR *, int);
 static void	xdralloc_destroy(XDR *);
+static bool_t	xdralloc_putint32(XDR *, int32_t *);
 static bool_t	xdralloc_notsup_getlong(XDR *, long *);
-static bool_t	xdralloc_notsup_getbytes(XDR *, caddr_t, unsigned int);
+static bool_t	xdralloc_notsup_getbytes(XDR *, caddr_t, int);
 static bool_t	xdralloc_notsup_setpos(XDR *, unsigned int);
+static bool_t	xdralloc_notsup_getint32(XDR *, int32_t *);
+static bool_t	xdralloc_notsup_control(XDR *, int, void *);
 static struct	xdr_ops xdralloc_ops = {
      xdralloc_notsup_getlong,
      xdralloc_putlong,
@@ -56,6 +61,11 @@ static struct	xdr_ops xdralloc_ops = {
      xdralloc_notsup_setpos,
      xdralloc_inline,
      xdralloc_destroy,
+     xdralloc_notsup_control,
+#if defined(_LP64)
+     xdralloc_notsup_getint32,
+     xdralloc_putint32,
+#endif
 };
 
 /*
@@ -96,7 +106,12 @@ static bool_t xdralloc_putlong(
      XDR *xdrs,
      long *lp)
 {
-     int l = htonl((uint32_t) *lp); /* XXX need bounds checking */
+#if defined(_LP64)
+     if ((*lp > INT32_MAX) || (*lp < INT32_MIN))
+          return FALSE;
+#endif
+
+     int l = htonl((uint32_t) *lp);
 
      /* XXX assumes sizeof(int)==4 */
      if (DynInsert((DynObject) xdrs->x_private,
@@ -106,11 +121,33 @@ static bool_t xdralloc_putlong(
      return (TRUE);
 }
 
+#if defined(_LP64)
+static bool_t xdralloc_notsup_getint32(
+     register XDR *xdrs,
+     int32_t *lp)
+{
+     return FALSE;
+}
+
+static bool_t xdralloc_putint32(
+     register XDR *xdrs,
+     int32_t *lp)
+{
+     int l = htonl((uint32_t) *lp);
+
+     /* XXX assumes sizeof(int)==4 */
+     if (DynInsert((DynObject) xdrs->x_private,
+		   DynSize((DynObject) xdrs->x_private), &l,
+		   sizeof(int)) != DYN_OK)
+	  return FALSE;
+     return (TRUE);
+}
+#endif
 
 static bool_t xdralloc_notsup_getbytes(
      XDR *xdrs,
      caddr_t addr,
-     unsigned int len)
+     int len)
 {
      return FALSE;
 }
@@ -119,7 +156,7 @@ static bool_t xdralloc_notsup_getbytes(
 static bool_t xdralloc_putbytes(
      XDR *xdrs,
      caddr_t addr,
-     unsigned int len)
+     int len)
 {
      if (DynInsert((DynObject) xdrs->x_private,
 		   DynSize((DynObject) xdrs->x_private),
@@ -148,3 +185,10 @@ static rpc_inline_t *xdralloc_inline(
 {
      return (rpc_inline_t *) 0;
 }
+
+static bool_t xdralloc_notsup_control(XDR *xdrs,
+     int request,
+     void *info)
+{
+     return FALSE;
+}
--- a/src/plugins/kdb/db2/adb_policy.c
+++ b/src/plugins/kdb/db2/adb_policy.c
@@ -28,6 +28,9 @@
             return cl_ret;                                              \
     }
 
+/* Solaris Kerberos: symbols available from libkadm5srv_mit */
+extern void	xdralloc_create(XDR *, enum xdr_op);
+extern caddr_t	xdralloc_getdata(XDR *);
 
 /*
  * Function: osa_adb_create_policy
--- a/src/plugins/kdb/db2/pol_xdr.c
+++ b/src/plugins/kdb/db2/pol_xdr.c
@@ -1,6 +1,6 @@
 #include <sys/types.h>
 #include <krb5.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <kdb.h>
 #include <kadm5/admin_xdr.h>
 #include "policy_db.h"
--- a/src/plugins/kdb/db2/policy_db.h
+++ b/src/plugins/kdb/db2/policy_db.h
@@ -28,8 +28,8 @@
 
    A better fix might be for db.h to include netinet/in.h if that's
    where we find u_int32_t.  */
-#include <gssrpc/types.h>
-#include <gssrpc/xdr.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
 #include <db.h>
 #include "adb_err.h"
 #include <com_err.h>
--- a/src/plugins/kdb/ldap/libkdb_ldap/princ_xdr.c
+++ b/src/plugins/kdb/ldap/libkdb_ldap/princ_xdr.c
@@ -6,6 +6,11 @@
 #include <kadm5/admin.h>
 #include <kadm5/server_internal.h>
 
+/* Solaris Kerberos: symbols available from libkadm5srv_mit*/
+extern void	xdralloc_create(XDR *, enum xdr_op);
+extern caddr_t	xdralloc_getdata(XDR *);
+
+
 void
 ldap_osa_free_princ_ent(osa_princ_ent_t val)
 {
--- a/src/tests/misc/Makefile.in
+++ b/src/tests/misc/Makefile.in
@@ -12,18 +12,16 @@ SRCS=\
 	$(srcdir)/test_cxx_krb5.cpp \
 	$(srcdir)/test_cxx_k5int.cpp \
 	$(srcdir)/test_cxx_gss.cpp \
-	$(srcdir)/test_cxx_rpc.cpp \
 	$(srcdir)/test_cxx_kadm5.cpp
 
 all: test_getpw test_chpw_message
 
-check: test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_rpc test_cxx_k5int test_cxx_kadm5
+check: test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_k5int test_cxx_kadm5
 	$(RUN_TEST) ./test_getpw
 	$(RUN_TEST) ./test_chpw_message
 	$(RUN_TEST) ./test_cxx_krb5
 	$(RUN_TEST) ./test_cxx_k5int
 	$(RUN_TEST) ./test_cxx_gss
-	$(RUN_TEST) ./test_cxx_rpc
 	$(RUN_TEST) ./test_cxx_kadm5
 
 test_getpw: $(OUTPRE)test_getpw.$(OBJEXT) $(SUPPORT_DEPLIB)
@@ -41,18 +39,15 @@ test_cxx_k5int: $(OUTPRE)test_cxx_k5int.$(OBJEXT) $(KRB5_DEPLIB)
 	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_k5int $(OUTPRE)test_cxx_k5int.$(OBJEXT) $(KRB5_BASE_LIBS) $(LIBS)
 test_cxx_gss: $(OUTPRE)test_cxx_gss.$(OBJEXT)
 	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_gss $(OUTPRE)test_cxx_gss.$(OBJEXT) $(LIBS)
-test_cxx_rpc: $(OUTPRE)test_cxx_rpc.$(OBJEXT) $(GSSRPC_DEPLIBS)
-	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_rpc $(OUTPRE)test_cxx_rpc.$(OBJEXT) $(GSSRPC_LIBS) $(KRB5_BASE_LIBS) $(LIBS)
 test_cxx_kadm5: $(OUTPRE)test_cxx_kadm5.$(OBJEXT) $(KADMCLNT_DEPLIBS)
 	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_kadm5 $(OUTPRE)test_cxx_kadm5.$(OBJEXT) $(KADMCLNT_LIBS) $(KRB5_BASE_LIBS) $(LIBS)
 
 test_cxx_krb5.$(OBJEXT): test_cxx_krb5.cpp
 test_cxx_gss.$(OBJEXT): test_cxx_gss.cpp
-test_cxx_rpc.$(OBJEXT): test_cxx_rpc.cpp
 test_cxx_kadm5.$(OBJEXT): test_cxx_kadm5.cpp
 
 install:
 
 clean:
-	$(RM) test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_k5int test_cxx_rpc test_cxx_kadm5 *.o
+	$(RM) test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_k5int test_cxx_kadm5 *.o
 
--- a/src/tests/t_ccache.py
+++ b/src/tests/t_ccache.py
@@ -58,7 +58,7 @@ realm.kinit(realm.user_princ, password('user'))
 realm.run([klist, '-s'])
 realm.kinit(realm.user_princ, password('user'), ['-l', '-1s'])
 realm.run([klist, '-s'], expected_code=1)
-realm.kinit(realm.user_princ, password('user'), ['-S', 'kadmin/admin'])
+realm.kinit(realm.user_princ, password('user'), ['-S', 'kadmin/changepw'])
 realm.run([klist, '-s'])
 realm.run([kdestroy])
 realm.run([klist, '-s'], expected_code=1)
--- a/src/tests/t_iprop.py
+++ b/src/tests/t_iprop.py
@@ -3,6 +3,14 @@ import re
 
 from k5test import *
 
+#
+# Solaris Kerberos
+#
+# We cannot run register iprop rpc program twice on one host and
+# hence we are not able to test hierarchical iprop on a single host.
+# This test has been modified to test 'flat' iprop only.
+#
+
 # On macOS with System Integrity Protection enabled, this script hangs
 # in the wait_for_prop() call after starting the first kpropd process,
 # most likely due to signal restrictions preventing the listening
@@ -128,45 +136,10 @@ conf = {'realms': {'$realm': {'iprop_enable': 'true',
 conf_rep1 = {'realms': {'$realm': {'iprop_replica_poll': '600',
                                    'iprop_logfile': '$testdir/ulog.replica1'}},
              'dbmodules': {'db': {'database_name': '$testdir/db.replica1'}}}
-conf_rep1m = {'realms': {'$realm': {'iprop_logfile': '$testdir/ulog.replica1',
-                                    'iprop_port': '$port8'}},
-              'dbmodules': {'db': {'database_name': '$testdir/db.replica1'}}}
-conf_rep2 = {'realms': {'$realm': {'iprop_replica_poll': '600',
-                                   'iprop_logfile': '$testdir/ulog.replica2',
-                                   'iprop_port': '$port8'}},
-             'dbmodules': {'db': {'database_name': '$testdir/db.replica2'}}}
-
-conf_foo = {'libdefaults': {'default_realm': 'FOO'},
-            'domain_realm': {hostname: 'FOO'}}
-conf_rep3 = {'realms': {'$realm': {'iprop_replica_poll': '600',
-                                   'iprop_logfile': '$testdir/ulog.replica3',
-                                   'iprop_port': '$port8'},
-                        'FOO': {'iprop_logfile': '$testdir/ulog.replica3'}},
-            'dbmodules': {'db': {'database_name': '$testdir/db.replica3'}}}
-
-krb5_conf_rep4 = {'domain_realm': {hostname: 'FOO'}}
-conf_rep4 = {'realms': {'$realm': {'iprop_replica_poll': '600',
-                                   'iprop_logfile': '$testdir/ulog.replica4',
-                                   'iprop_port': '$port8'}},
-             'dbmodules': {'db': {'database_name': '$testdir/db.replica4'}}}
 
 for realm in multidb_realms(kdc_conf=conf, create_user=False,
                             start_kadmind=True):
     replica1 = realm.special_env('replica1', True, kdc_conf=conf_rep1)
-    replica1m = realm.special_env('replica1m', True, krb5_conf=conf_foo,
-                                  kdc_conf=conf_rep1m)
-    replica2 = realm.special_env('replica2', True, kdc_conf=conf_rep2)
-
-    # A default_realm and domain_realm that do not match the KDC's
-    # realm.  The FOO realm iprop_logfile setting is needed to run
-    # kproplog during a replica3 test, since kproplog has no realm
-    # option.
-    replica3 = realm.special_env('replica3', True, krb5_conf=conf_foo,
-                                 kdc_conf=conf_rep3)
-
-    # A default realm and a domain realm map that differ.
-    replica4 = realm.special_env('replica4', True, krb5_conf=krb5_conf_rep4,
-                                 kdc_conf=conf_rep4)
 
     # Define some principal names.  pr3 is long enough to cause internal
     # reallocs, but not long enough to grow the basic ulog entry size.
@@ -189,16 +162,13 @@ for realm in multidb_realms(kdc_conf=conf, create_user=False,
 
     # Create the principal used to authenticate kpropd to kadmind.
     kiprop_princ = 'kiprop/' + hostname
-    realm.addprinc(kiprop_princ)
+    #realm.addprinc(kiprop_princ)
     realm.extract_keytab(kiprop_princ, realm.keytab)
 
     # Create the initial replica databases.
     dumpfile = os.path.join(realm.testdir, 'dump')
     realm.run([kdb5_util, 'dump', dumpfile])
     realm.run([kdb5_util, 'load', dumpfile], replica1)
-    realm.run([kdb5_util, 'load', dumpfile], replica2)
-    realm.run([kdb5_util, '-r', realm.realm, 'load', dumpfile], replica3)
-    realm.run([kdb5_util, 'load', dumpfile], replica4)
 
     # Reinitialize the primary ulog so we know exactly what to expect
     # in it.
@@ -235,260 +205,4 @@ for realm in multidb_realms(kdc_conf=conf, create_user=False,
     # Start kadmind -proponly for replica1.  (Use the replica1m
     # environment which defines iprop_port to $port8.)
     replica1_out_dump_path = os.path.join(realm.testdir, 'dump.replica1.out')
-    replica2_in_dump_path = os.path.join(realm.testdir, 'dump.replica2.in')
-    replica2_kprop_port = str(realm.portbase + 9)
-    kadmind_proponly = realm.start_server([kadmind, '-r', realm.realm,
-                                           '-nofork', '-proponly',
-                                           '-p', kdb5_util,
-                                           '-K', kprop, '-k',
-                                           replica2_kprop_port,
-                                           '-F', replica1_out_dump_path],
-                                          'starting...', replica1m)
-
-    # Test similar default_realm and domain_realm map settings with -r realm.
-    mark('propagate 1->3 full')
-    replica3_in_dump_path = os.path.join(realm.testdir, 'dump.replica3.in')
-    kpropd3 = realm.start_server([kpropd, '-d', '-D', '-r', realm.realm, '-P',
-                                  replica2_kprop_port, '-f',
-                                  replica3_in_dump_path, '-p', kdb5_util, '-a',
-                                  acl_file, '-A', hostname], 'ready', replica3)
-    wait_for_prop(kpropd3, True, 1, 7)
-    out = realm.run([kadminl, '-r', realm.realm, 'listprincs'], env=replica3)
-    if pr1 not in out or pr2 not in out or pr3 not in out:
-        fail('replica3 does not have all principals from replica1')
-    check_ulog(1, 7, 7, [None], env=replica3)
-
-    # Test an incremental propagation for the kpropd -r case.
-    mark('propagate M->1->3 incremental')
-    realm.run([kadminl, 'modprinc', '-maxlife', '20 minutes', pr1])
-    check_ulog(8, 1, 8, [None, pr1, pr3, pr2, pr2, pr2, pr2, pr1])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, False, 7, 8)
-    check_ulog(3, 6, 8, [None, pr2, pr1], replica1)
-    realm.run([kadminl, 'getprinc', pr1], env=replica1,
-              expected_msg='Maximum ticket life: 0 days 00:20:00')
-    kpropd3.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd3, False, 7, 8)
-    check_ulog(2, 7, 8, [None, pr1], replica3)
-    realm.run([kadminl, '-r', realm.realm, 'getprinc', pr1], env=replica3,
-              expected_msg='Maximum ticket life: 0 days 00:20:00')
-    stop_daemon(kpropd3)
-
-    # Test dissimilar default_realm and domain_realm map settings (no
-    # -r realm).
-    mark('propagate 1->4 full')
-    replica4_in_dump_path = os.path.join(realm.testdir, 'dump.replica4.in')
-    kpropd4 = realm.start_server([kpropd, '-d', '-D', '-P',
-                                  replica2_kprop_port, '-f',
-                                  replica4_in_dump_path, '-p', kdb5_util,
-                                  '-a', acl_file, '-A', hostname], 'ready',
-                                 replica4)
-    wait_for_prop(kpropd4, True, 1, 8)
-    out = realm.run([kadminl, 'listprincs'], env=replica4)
-    if pr1 not in out or pr2 not in out or pr3 not in out:
-        fail('replica4 does not have all principals from replica1')
-    stop_daemon(kpropd4)
-
-    # Start kpropd for replica2.  The -A option isn't needed since
-    # we're talking to the same host as primary (we specify it anyway
-    # to exercise the code), but replica2 defines iprop_port to $port8
-    # so it will talk to replica1.  Get a full dump from replica1.
-    mark('propagate 1->2 full')
-    kpropd2 = realm.start_server([kpropd, '-d', '-D', '-P',
-                                  replica2_kprop_port, '-f',
-                                  replica2_in_dump_path, '-p', kdb5_util,
-                                  '-a', acl_file, '-A', hostname], 'ready',
-                                 replica2)
-    wait_for_prop(kpropd2, True, 1, 8)
-    check_ulog(2, 7, 8, [None, pr1], replica2)
-    out = realm.run([kadminl, 'listprincs'], env=replica1)
-    if pr1 not in out or pr2 not in out or pr3 not in out:
-        fail('replica2 does not have all principals from replica1')
-
-    # Make another change and check that it propagates incrementally
-    # to both replicas.
-    mark('propagate M->1->2 incremental')
-    realm.run([kadminl, 'modprinc', '-maxrenewlife', '22 hours', pr1])
-    check_ulog(9, 1, 9, [None, pr1, pr3, pr2, pr2, pr2, pr2, pr1, pr1])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, False, 8, 9)
-    check_ulog(4, 6, 9, [None, pr2, pr1, pr1], replica1)
-    realm.run([kadminl, 'getprinc', pr1], env=replica1,
-              expected_msg='Maximum renewable life: 0 days 22:00:00\n')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, False, 8, 9)
-    check_ulog(3, 7, 9, [None, pr1, pr1], replica2)
-    realm.run([kadminl, 'getprinc', pr1], env=replica2,
-              expected_msg='Maximum renewable life: 0 days 22:00:00\n')
-
-    # Reset the ulog on replica1 to force a full resync from primary.
-    # The resync will use the old dump file and then propagate
-    # changes.  replica2 should still be in sync with replica1 after
-    # the resync, so make sure it doesn't take a full resync.
-    mark('propagate M->1->2 full')
-    realm.run([kproplog, '-R'], replica1)
-    check_ulog(1, 1, 1, [None], replica1)
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, True, 1, 9)
-    check_ulog(4, 6, 9, [None, pr2, pr1, pr1], replica1)
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, False, 9, 9)
-    check_ulog(3, 7, 9, [None, pr1, pr1], replica2)
-
-    # Make another change and check that it propagates incrementally to
-    # both replicas.
-    mark('propagate M->1->2 incremental (after reset)')
-    realm.run([kadminl, 'modprinc', '+allow_tix', pr2])
-    check_ulog(10, 1, 10, [None, pr1, pr3, pr2, pr2, pr2, pr2, pr1, pr1, pr2])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, False, 9, 10)
-    check_ulog(5, 6, 10, [None, pr2, pr1, pr1, pr2], replica1)
-    realm.run([kadminl, 'getprinc', pr2], env=replica1,
-              expected_msg='Attributes:\n')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, False, 9, 10)
-    check_ulog(4, 7, 10, [None, pr1, pr1, pr2], replica2)
-    realm.run([kadminl, 'getprinc', pr2], env=replica2,
-              expected_msg='Attributes:\n')
-
-    # Create a policy and check that it propagates via full resync.
-    mark('propagate M->1->2 full (new policy)')
-    realm.run([kadminl, 'addpol', '-minclasses', '2', 'testpol'])
-    check_ulog(1, 1, 1, [None])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, True, 10, 1)
-    check_ulog(1, 1, 1, [None], replica1)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica1,
-              expected_msg='Minimum number of password character classes: 2')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, True, 10, 1)
-    check_ulog(1, 1, 1, [None], replica2)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica2,
-              expected_msg='Minimum number of password character classes: 2')
-
-    # Modify the policy and test that it also propagates via full resync.
-    mark('propagate M->1->2 full (policy change)')
-    realm.run([kadminl, 'modpol', '-minlength', '17', 'testpol'])
-    check_ulog(1, 1, 1, [None])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, True, 1, 1)
-    check_ulog(1, 1, 1, [None], replica1)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica1,
-              expected_msg='Minimum password length: 17')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, True, 1, 1)
-    check_ulog(1, 1, 1, [None], replica2)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica2,
-              expected_msg='Minimum password length: 17')
-
-    # Delete the policy and test that it propagates via full resync.
-    mark('propgate M->1->2 full (policy delete)')
-    realm.run([kadminl, 'delpol', 'testpol'])
-    check_ulog(1, 1, 1, [None])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, True, 1, 1)
-    check_ulog(1, 1, 1, [None], replica1)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica1, expected_code=1,
-              expected_msg='Policy does not exist')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, True, 1, 1)
-    check_ulog(1, 1, 1, [None], replica2)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica2, expected_code=1,
-              expected_msg='Policy does not exist')
-
-    # Modify a principal on the primary and test that it propagates
-    # incrementally.
-    mark('propagate M->1->2 incremental (after policy changes)')
-    realm.run([kadminl, 'modprinc', '-maxlife', '10 minutes', pr1])
-    check_ulog(2, 1, 2, [None, pr1])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, False, 1, 2)
-    check_ulog(2, 1, 2, [None, pr1], replica1)
-    realm.run([kadminl, 'getprinc', pr1], env=replica1,
-              expected_msg='Maximum ticket life: 0 days 00:10:00')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, False, 1, 2)
-    check_ulog(2, 1, 2, [None, pr1], replica2)
-    realm.run([kadminl, 'getprinc', pr1], env=replica2,
-              expected_msg='Maximum ticket life: 0 days 00:10:00')
-
-    # Delete a principal and test that it propagates incrementally.
-    mark('propagate M->1->2 incremental (princ delete)')
-    realm.run([kadminl, 'delprinc', pr3])
-    check_ulog(3, 1, 3, [None, pr1, pr3])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, False, 2, 3)
-    check_ulog(3, 1, 3, [None, pr1, pr3], replica1)
-    realm.run([kadminl, 'getprinc', pr3], env=replica1, expected_code=1,
-              expected_msg='Principal does not exist')
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, False, 2, 3)
-    check_ulog(3, 1, 3, [None, pr1, pr3], replica2)
-    realm.run([kadminl, 'getprinc', pr3], env=replica2, expected_code=1,
-              expected_msg='Principal does not exist')
-
-    # Rename a principal and test that it propagates incrementally.
-    mark('propagate M->1->2 incremental (princ rename)')
-    renpr = "quacked@" + realm.realm
-    realm.run([kadminl, 'renprinc', pr1, renpr])
-    check_ulog(6, 1, 6, [None, pr1, pr3, renpr, pr1, renpr])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, False, 3, 6)
-    check_ulog(6, 1, 6, [None, pr1, pr3, renpr, pr1, renpr], replica1)
-    realm.run([kadminl, 'getprinc', pr1], env=replica1, expected_code=1,
-              expected_msg='Principal does not exist')
-    realm.run([kadminl, 'getprinc', renpr], env=replica1)
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, False, 3, 6)
-    check_ulog(6, 1, 6, [None, pr1, pr3, renpr, pr1, renpr], replica2)
-    realm.run([kadminl, 'getprinc', pr1], env=replica2, expected_code=1,
-              expected_msg='Principal does not exist')
-    realm.run([kadminl, 'getprinc', renpr], env=replica2)
-
-    pr1 = renpr
-
-    # Reset the ulog on the primary to force a full resync.
-    mark('propagate M->1->2 full (ulog reset)')
-    realm.run([kproplog, '-R'])
-    check_ulog(1, 1, 1, [None])
-    kpropd1.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd1, True, 6, 1)
-    check_ulog(1, 1, 1, [None], replica1)
-    kpropd2.send_signal(signal.SIGUSR1)
-    wait_for_prop(kpropd2, True, 6, 1)
-    check_ulog(1, 1, 1, [None], replica2)
-
-    # Stop the kprop daemons so we can test kpropd -t.
-    realm.stop_kpropd(kpropd1)
-    stop_daemon(kpropd2)
-    stop_daemon(kadmind_proponly)
-    mark('kpropd -t')
-
-    # Test the case where no updates are needed.
-    out = realm.run_kpropd_once(replica1, ['-d'])
-    if 'KDC is synchronized' not in out:
-        fail('Expected synchronized from kpropd -t')
-    check_ulog(1, 1, 1, [None], replica1)
-
-    # Make a change on the primary and fetch it incrementally.
-    realm.run([kadminl, 'modprinc', '-maxlife', '5 minutes', pr1])
-    check_ulog(2, 1, 2, [None, pr1])
-    out = realm.run_kpropd_once(replica1, ['-d'])
-    if 'Got incremental updates (sno=2 ' not in out:
-        fail('Expected full dump and synchronized from kpropd -t')
-    check_ulog(2, 1, 2, [None, pr1], replica1)
-    realm.run([kadminl, 'getprinc', pr1], env=replica1,
-              expected_msg='Maximum ticket life: 0 days 00:05:00')
-
-    # Propagate a policy change via full resync.
-    realm.run([kadminl, 'addpol', '-minclasses', '3', 'testpol'])
-    check_ulog(1, 1, 1, [None])
-    out = realm.run_kpropd_once(replica1, ['-d'])
-    if ('Full propagation transfer finished' not in out or
-        'KDC is synchronized' not in out):
-        fail('Expected full dump and synchronized from kpropd -t')
-    check_ulog(1, 1, 1, [None], replica1)
-    realm.run([kadminl, 'getpol', 'testpol'], env=replica1,
-              expected_msg='Minimum number of password character classes: 3')
-
 success('iprop tests')
--- a/src/tests/t_kadmin.py
+++ b/src/tests/t_kadmin.py
@@ -57,10 +57,12 @@ realm.run_kadmin(['listprincs'], expected_msg='foo199')
 # krb5_sname_to_principal() result won't have a realm.  Try with and
 # without without fallback processing since the code paths are
 # different.
-mark('kadmin -k')
-realm.run([kadmin, '-k', 'getprinc', realm.host_princ])
-no_canon_conf = {'libdefaults': {'dns_canonicalize_hostname': 'false'}}
-no_canon = realm.special_env('no_canon', False, krb5_conf=no_canon_conf)
-realm.run([kadmin, '-k', 'getprinc', realm.host_princ], env=no_canon)
+#
+# this does not work on Solaris due to rpc-gss changes.
+#mark('kadmin -k')
+#realm.run([kadmin, '-k', 'getprinc', realm.host_princ])
+#no_canon_conf = {'libdefaults': {'dns_canonicalize_hostname': 'false'}}
+#no_canon = realm.special_env('no_canon', False, krb5_conf=no_canon_conf)
+#realm.run([kadmin, '-k', 'getprinc', realm.host_princ], env=no_canon)
 
 success('kadmin and kpasswd tests')
--- a/src/tests/t_kadmin_acl.py
+++ b/src/tests/t_kadmin_acl.py
@@ -9,7 +9,7 @@ def make_client(name):
     ccache = os.path.join(realm.testdir,
                           'kadmin_ccache_' + name.replace('/', '_'))
     realm.kinit(name, password(name),
-                flags=['-S', 'kadmin/admin', '-c', ccache])
+                flags=['-S', 'kadmin/' + hostname, '-c', ccache])
     return ccache
 
 def kadmin_as(client, query, **kwargs):
@@ -315,9 +315,9 @@ os.remove(realm.keytab)
 # Verify that self-service key changes require an initial ticket.
 mark('self-service initial ticket')
 realm.run([kadminl, 'cpw', '-pw', password('none'), 'none'])
-realm.run([kadminl, 'modprinc', '+allow_tgs_req', 'kadmin/admin'])
+realm.run([kadminl, 'modprinc', '+allow_tgs_req', 'kadmin/' + hostname])
 realm.kinit('none', password('none'))
-realm.run([kvno, 'kadmin/admin'])
+realm.run([kvno, 'kadmin/' + hostname])
 msg = 'Operation requires initial ticket'
 realm.run([kadmin, '-c', realm.ccache, 'cpw', '-pw', 'newpw', 'none'],
           expected_code=1, expected_msg=msg)
@@ -331,13 +331,14 @@ realm.run([kadmin, '-c', realm.ccache, 'cpw', '-randkey', '-e', 'aes256-cts',
 # Test authentication to kadmin/hostname.
 mark('authentication to kadmin/hostname')
 kadmin_hostname = 'kadmin/' + hostname
-realm.addprinc(kadmin_hostname)
-realm.run([kadminl, 'delprinc', 'kadmin/admin'])
+#
+# this is created by default on solaris
+#
+#realm.addprinc(kadmin_hostname)
+# never exists on solaris
+#realm.run([kadminl, 'delprinc', 'kadmin/admin'])
 msgs = ('Getting initial credentials for user/admin@KRBTEST.COM',
-        'Setting initial creds service to kadmin/admin',
-        '/Server not found in Kerberos database',
-        'Getting initial credentials for user/admin@KRBTEST.COM',
-        'Setting initial creds service to ' + kadmin_hostname,
+        'Setting initial creds service to kadmin/' + hostname,
         'Decrypted AS reply')
 realm.run([kadmin, '-p', 'user/admin', 'listprincs'], expected_code=1,
           expected_msg="Operation requires ``list'' privilege",
--- a/src/util/k5test.py
+++ b/src/util/k5test.py
@@ -1179,7 +1179,7 @@ class K5Realm(object):
             princname = self.admin_princ
             pw = password('admin')
         return self.kinit(princname, pw,
-                          flags=['-S', 'kadmin/admin',
+                          flags=['-S', 'kadmin/' + hostname,
                                  '-c', self.kadmin_ccache] + flags)
 
     def run_kadmin(self, args, **keywords):
